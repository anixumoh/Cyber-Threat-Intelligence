import { Component, Input, OnInit, ViewEncapsulation } from '@angular/core';

import { capitalize, isComposedDict, isString, isStringsArray, isStringsDict } from './render_components.functions';
import { ioaMetaCount } from '../ioa.symbols';

@Component({
  selector: 'composed-dict',
  templateUrl: './composedDict.html',
  encapsulation: ViewEncapsulation.None,
  styleUrls: ['./composeDict.scss'],
})
export class ComposedDictionary implements OnInit {
  @Input() key = undefined;
  @Input() value = undefined;
  @Input() parentKey = undefined;
  metaCountField = ioaMetaCount;
  selectedKey;
  loadedKey = {};

  dict;
  dicts;
  complete_key;
  keyPath = '';

  stringArrayKeys = [
    'tcp',
    'tcp_dead',
    'udp',
    'regkey_created',
    'regkey_deleted',
    'regkey_enumerated',
    'regkey_opened',
    'regkey_read',
    'regkey_written',
  ];
  private stringDictKeys = [''];
  private composedDictKeys = [''];

  constructor() {}

  ngOnInit() {
    this.process_dict();
  }

  cmp_capitalize(text) {
    return capitalize(text);
  }

  cmp_isString(value) {
    return isString(value);
  }

  cmp_isStringsArray(key, value, inArray) {
    return isStringsArray(key, value, inArray);
  }

  cmp_isStringsDict(key, value, inArray) {
    return isStringsDict(key, value, inArray);
  }

  cmp_isComposedDict(key, value, inArray) {
    return isComposedDict(key, value, inArray);
  }

  isEmptyObject(obj) {
    return obj && Object.keys(obj).length === 0;
  }

  selectKey(key) {
    this.selectedKey = key;
    this.loadedKey[key] = true;
  }

  private process_dict() {
    this.dict = this.value;
    this.dicts = this.transform(this.value);
    if (this.dicts && this.dicts.length > 0) {
      this.selectKey(this.dicts[0].key);
    }
    this.complete_key = this.parentKey ? this.parentKey + '.' + this.key : this.key;
    this.keyPath = this.complete_key;
  }

  private transform(iterable: any): any {
    const result = [];
    if (iterable == null) {
      return result;
    }
    if (iterable.entries) {
      iterable.forEach((value, key) => {
        result.push({ key, value });
      });
    } else {
      for (const key in iterable) {
        if (iterable.hasOwnProperty(key)) {
          result.push({ key, value: iterable[key] });
        }
      }
    }
    return result;
  }
}
