import { ChangeDetectorRef, Component, OnDestroy, OnInit } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, finalize, switchMap, take, takeUntil, filter } from 'rxjs/operators';
import * as moment from 'moment';

import { ISelectItem } from '../../../shared/components/select/select.component';
import { OrganizationService } from '../../../dashboard/organization/organization.service';
import { ModuleModel, OrganizationModel } from 'app/dashboard/organization/models';
import { NewTabService } from 'app/services/new-tab.service';
import { Store } from 'app/services/store/store';

import { MalwareAnalysisService } from 'app/core/models/malware-analysis.service';
import { getGranularity } from 'app/utils/functions';
import { beforeUpload } from 'app/shared/utils/common.utils';
import { chain, clone, findIndex, set } from 'lodash';

@Component({
  selector: 'app-malware-analysis-list',
  templateUrl: './malware-analysis-list.component.html',
  styleUrls: ['./malware-analysis-list.component.scss']
})
export class MalwareAnalysisListComponent implements OnInit, OnDestroy {
  items: any = [];
  loading = false;
  searchText = '';
  page = 0;
  count = 0;
  limit = 15;
  listError = '';
  sort = '';
  searchOption = 'sha256';
  analyzedOnly = false;
  tooltipText =
    'Supported formats include Windows/Linux/Android binaries, Office and PDF documents, Javascript and VisualBasic scripts, and ZIP files.';
  limits: ISelectItem[] = [
    { name: '10', value: 10 },
    { name: '15', value: 15 },
    { name: '20', value: 20 },
    { name: '30', value: 30 },
    { name: '50', value: 50 }
  ];
  searchOptions = [
    { id: 'sha256', value: 'SHA256' },
    { id: 'userName', value: 'Username' },
    { id: 'type', value: 'Type' },
    { id: 'filename', value: 'Filename' }
  ];
  filename = '';
  activeModule: ModuleModel;
  activeOrganization: OrganizationModel;
  filesStatus = [];
  since = '';
  to = '';
  formattedSince = null;
  formattedTo = null;
  timezone = '';
  chartData = [];
  requestSubject = new BehaviorSubject<boolean>(false);
  isSearchOpen = false;
  private searchByTextSubject = new Subject();
  private searchByShaSubject = new Subject();
  private uploadObservables = [];
  private readonly destroy$ = new Subject<void>();

  constructor(
    private organizationService: OrganizationService,
    private newTabService: NewTabService,
    private malwareAnalysisService: MalwareAnalysisService,
    private store: Store,
    private cd: ChangeDetectorRef
  ) {
    if (!this.cd.detectChanges['destroyed']) {
      this.cd.markForCheck();
    }
  }

  get isSHAOptionSelected() {
    return this.searchOption === 'sha256';
  }

  onSearchTerm(value: string) {
    this[this.isSHAOptionSelected ? 'searchByShaSubject' : 'searchByTextSubject'].next(value);
  }

  ngOnInit() {
    this.organizationService
      .getCurrentContext()
      .pipe(
        takeUntil(this.destroy$),
        take(1),
        switchMap((context) => {
          if (context) {
            this.activeModule = context.currentModule;
            this.activeOrganization = context.currentOrganization;
            return this.store.select('roleList');
          }
        })
      )
      .subscribe((res) => {
        this.timezone = res['timezone'];
      });

    this.searchByShaSubject
      .asObservable()
      .pipe(
        takeUntil(this.destroy$),
        filter((term: any) => term === '' || term.length >= 1),
        debounceTime(0),
        distinctUntilChanged()
      )
      .subscribe(() => {
        this.reload();
      });

    this.searchByTextSubject
      .asObservable()
      .pipe(
        takeUntil(this.destroy$),
        filter((term: any) => term === '' || term.length >= 1),
        debounceTime(0),
        distinctUntilChanged()
      )
      .subscribe(() => {
        this.reload();
      });

    this.list();
    this.getChartData();
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  changeSearch() {
    if (this.searchText) {
      this.reload();
    }
  }

  reload() {
    this.page = 0;
    this.list();
    this.getChartData();
  }

  uploadFile(filesArg) {
    const files = Array.prototype.slice.call(filesArg); // Files to Array
    const getFileId = (file) => `${file.name}:${file.lastModified}:${file.size}`;

    this.filesStatus = [
      ...this.filesStatus,
      ...files.map((f) => ({ name: f.name, status: 'uploading', id: getFileId(f) }))
    ];

    files.forEach((f, indx) => {
      ((file, index) => {
        const setStatus = (fn) => {
          this.filesStatus = this.filesStatus.map((s) => (s.id === getFileId(file) ? fn(s) : s));
        };

        if (this.filesStatus.some(({ name, status }: any) => name === file.name && status !== 'error')) {
          if (beforeUpload(file)) {
            this.uploadOneFileOrUrl.call(this, file, setStatus, false);
          } else {
            this.filesStatus = this.filesStatus.map((f) =>
              f.name === file.name
                ? chain(f)
                    .set('status', 'error')
                    .set('errorMessage', { error: { message: 'malware.max_file_size' } })
                    .value()
                : f
            );
          }
        }
      })(f, indx);
    });
  }

  isClickingOnButton(classList: DOMTokenList): boolean {
    return ['btn', 'fa', 'icon-copy'].some((className) => classList.contains(className));
  }

  openDetails(event, item) {
    if (
      event.target.type === 'checkbox' ||
      item.statusName !== 'Analyzed' ||
      this.isClickingOnButton(event.target.classList)
    ) {
      return;
    }
    const route = `/dashboard/organizations/${this.activeOrganization.id}/modules/${this.activeModule.id}/threat_context/malwares/${item.sha256}`;
    this.newTabService.openNewTab(event, route);
  }

  updateTLP(status, item, index) {
    this.malwareAnalysisService
      .updateTLP(this.activeOrganization.id, this.activeModule.id, item.md5, status)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.items[index].tlp = status;
      });
  }

  reUploadFile(fileObject) {
    const fileOrUrl = fileObject.file || fileObject.url;
    const now = new Date().getTime();

    const getFileId = (file) => `${file.name}:${file.lastModified}:${file.size}`;
    const getFileOrUrlId = (f) => (fileObject.isUrl ? `url:${now}` : getFileId(f));
    const setStatus = (fn) =>
      (this.filesStatus = this.filesStatus.map((s) => (s.id === getFileOrUrlId(s) ? fn(s) : s)));

    if (fileObject.status !== 'error') {
      this.filesStatus = this.filesStatus.map((f) =>
        f.id === fileObject.id
          ? chain(f).set('status', 'uploading').set('id', getFileOrUrlId(f)).omit(['errorMessage']).value()
          : f
      );

      this.uploadOneFileOrUrl.call(this, fileOrUrl, setStatus, fileObject.isUrl);
    }
  }

  removeFile(fileId) {
    const statusTmp = clone(this.filesStatus);
    const index = findIndex(this.filesStatus, (f) => f.id === fileId);

    statusTmp.splice(index, 1);
    this.filesStatus = clone(statusTmp);
  }

  cancelUploads() {
    this.filesStatus = [];
    this.uploadObservables.forEach((o) => o.unsubscribe());
    this.uploadObservables = [];
  }

  onCloseUploaderStatus() {
    this.filesStatus = [];
  }

  onDateFilter(e) {
    const toInitialOfDay = (d) =>
      moment(d)
        .set({
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        })
        .utc();
    const toEndOfDay = (d) =>
      moment(d)
        .set({
          hour: 23,
          minute: 59,
          second: 59,
          millisecond: 9999
        })
        .utc();
    const since = moment(e.startDateCtrl);
    const to = moment(e.endDateCtrl);
    this.since = since.format('MM') + '.' + since.format('DD') + '.' + since.format('YYYY');
    this.to = to.format('MM') + '.' + to.format('DD') + '.' + to.format('YYYY');
    this.formattedSince = since?.format ? toInitialOfDay(since).format('x') : undefined;
    this.formattedTo = to?.format ? toEndOfDay(to).format('x') : undefined;
    this.reload();
  }

  onChangeLimit(item: ISelectItem) {
    this.limit = item.value;
    this.reload();
  }

  applyAnalyzedFilter() {
    this.analyzedOnly = !this.analyzedOnly;
    this.reload();
  }

  onPageChange({ page }) {
    this.page = page;
    this.list();
  }

  resetDates() {
    this.formattedSince = '';
    this.formattedTo = '';
    this.reload();
  }

  resetSearchInput() {
    this.searchText = '';
    this.reload();
  }

  sortBy(value) {
    this.sort = value;
    this.list();
  }

  updatedText(text: string) {
    const term = text.trim();
    if (!term) {
      return;
    }
    this.onSearchTerm(term);
  }

  changeOption(e) {
    this.searchOption = e;
    this.reload();
  }

  commonsParams() {
    return {
      filename: this.searchOption === 'filename' && this.searchText ? this.searchText : undefined,
      sha256: this.searchOption === 'sha256' && this.searchText ? this.searchText : undefined,
      userName: this.searchOption === 'userName' && this.searchText ? this.searchText : undefined,
      type: this.searchOption === 'type' && this.searchText ? this.searchText : undefined,
      statusName: this.analyzedOnly ? 'Analyzed' : undefined
    };
  }

  list() {
    this.listError = '';
    this.loading = true;
    const params: any = {
      ...this.commonsParams(),
      maxRows: this.limit,
      page: this.page + 1,
      since: this.formattedSince ? this.formattedSince : undefined,
      to: this.formattedTo ? this.formattedTo : undefined,
      sort: !!this.sort,
      o: this.sort
    };

    this.malwareAnalysisService
      .list(this.activeOrganization.id, this.activeModule.id, params)
      .pipe(
        takeUntil(this.destroy$),
        take(1),
        finalize(() => (this.loading = false))
      )
      .subscribe(
        (res) => {
          this.items = res.list;
          this.count = res.total;
        },
        () => {
          this.listError = 'There was an error retrieving the data. Please, try again later.';
        }
      );
  }

  getChartData() {
    const convertDate = (d) => {
      const dateObj = moment(d).toDate();
      return `${dateObj.getFullYear()}${('0' + (dateObj.getMonth() + 1)).slice(-2)}${('0' + dateObj.getDate()).slice(
        -2
      )}`;
    };

    const params: any = {
      ...this.commonsParams(),
      since: this.since ? convertDate(this.since) : undefined,
      to: this.to ? convertDate(this.to) : undefined,
      timezone: this.timezone,
      facet: 'TIME',
      orderBy: 'KEY',
      granularity: getGranularity(this.since, this.to) ? getGranularity(this.since, this.to).granularity : 'DAY',
      limit: getGranularity(this.since, this.to) ? getGranularity(this.since, this.to).limit : ''
    };

    this.malwareAnalysisService
      .getChartData(this.activeOrganization.id, this.activeModule.id, params)
      .pipe(takeUntil(this.destroy$))
      .subscribe((res) => {
        this.chartData = res.map((row: any) => ({
          ...row,
          date: new Date(row.endDate)
        }));
      });
  }

  openSearch() {
    this.isSearchOpen = !this.isSearchOpen;
  }

  private uploadOneFileOrUrl(fileOrUrl, setStatus) {
    const setError = (err) => (s) =>
      chain(s).set('status', 'error').set('errorMessage', err).set('file', fileOrUrl).value();
    const onNext = (time) => setStatus((s) => set(s, 'estimatedTime', time));
    const onError = (err) => setStatus(setError(err));
    const onComplete = () => {
      if (this.activeModule && this.activeModule.id) {
        this.requestSubject.next(true);
        this.reload();
      }
      return setStatus((s) => set(s, 'status', 'complete'));
    };

    const observable = this.malwareAnalysisService
      .uploadMalwareFile(this.activeOrganization.id, this.activeModule.id, this.activeModule.moduleName, fileOrUrl)
      .pipe(takeUntil(this.destroy$))
      .subscribe(onNext, onError, onComplete);

    this.uploadObservables.push(observable);
  }
}
