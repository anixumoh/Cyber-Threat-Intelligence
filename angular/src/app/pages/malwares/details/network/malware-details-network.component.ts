import { Component, OnDestroy, OnInit, ViewEncapsulation } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, take } from 'rxjs/operators';
import { MalwaresStore } from '../malwares-store';
import { MalwareMapStore } from '../malware-map-store';
import { MalwaresService } from '../../../../core/models/malwares.service';
import { OrganizationService } from '../../../../dashboard/organization/organization.service';

@Component({
  selector: 'app-malware-details-network',
  templateUrl: './malware-details-network.component.html',
  encapsulation: ViewEncapsulation.None,
  styleUrls: ['./malware-details-network.component.scss']
})
export class MalwareDetailsNetworkComponent implements OnInit, OnDestroy {
  ips = [];
  domains = [];
  network;
  tabs = {
    dns: 'DNS',
    tcp: 'TCP',
    udp: 'UDP',
    http: 'HTTP/S',
    icmp: 'ICMP',
    irc: 'IRC',
    smtp: 'SMTP',
    blacklisted: 'Blacklisted'
  };
  activeTab = this.tabs.dns;
  mapdata = [];
  udp = [];
  tcp = [];
  virustotalIP = 'https://www.virustotal.com/en/ip-address/';
  virustotalDomain = 'https://www.virustotal.com/en/domain/';
  DomainBigData = 'http://domainbigdata.com/';
  activeModule;
  activeOrganization;
  private readonly destroy$ = new Subject<void>();

  constructor(
    private store: MalwaresStore,
    private mapStore: MalwareMapStore,
    private malwaresService: MalwaresService,
    private organizationService: OrganizationService
  ) {}

  ngOnInit() {
    this.organizationService
      .getCurrentContext()
      .pipe(takeUntil(this.destroy$), take(1))
      .subscribe((context) => {
        this.activeModule = context.currentModule;
        this.activeOrganization = context.currentOrganization;
      });

    this.store.state$.pipe(takeUntil(this.destroy$)).subscribe((data) => {
      if (data) {
        const { network } = data;
        if (data['blueliv'].hasOwnProperty('blacklisted')) {
          network['blacklisted'] = data['blueliv']['blacklisted'];
        }
        this.network = network;
        this.ips = this.getAllIps();
        this.getAllDomains();
      }
    });

    this.mapStore.state$.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      if (value) {
        this.mapdata = value;
      }
    });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  getTCPCount() {
    let count = 0;
    if (!this.network) {
      return count;
    }
    if (this.network.tcp) {
      count += this.network.tcp.length || 0;
    }
    if (this.network.tcp_dead) {
      count += this.network.tcp_dead.length || 0;
    }
    return count;
  }

  getHttpCount() {
    let count = 0;
    if (!this.network) {
      return count;
    }
    if (this.network.http_ex) {
      count += this.network.http_ex.length || 0;
    }
    if (this.network.https_ex) {
      count += this.network.https_ex.length || 0;
    }
    return count;
  }

  private collectDomainsFromReport() {
    const domains_fqdn = [];
    const report_keys = ['domains', 'dns'];
    for (const key of report_keys) {
      for (const data of this.network[key]) {
        let entry;
        if (data.hasOwnProperty('domain')) {
          entry = data['domain'];
        }
        if (data.hasOwnProperty('request')) {
          entry = data['request'];
        }
        if (domains_fqdn.indexOf(entry) === -1) {
          domains_fqdn.push(entry);
        }
      }
    }
    return domains_fqdn;
  }

  private getDomainIds(domains_fqdn) {
    for (const domain of domains_fqdn) {
      this.domains.push({
        value: domain
      });
    }
  }

  private getAllDomains() {
    const domains_fqdn = this.collectDomainsFromReport();
    this.getDomainIds(domains_fqdn);
  }

  private getAllIps() {
    const out = this.network['hosts'];
    if (!this.network.hasOwnProperty('dead_hosts')) {
      return out;
    }
    for (const host of this.network['dead_hosts']) {
      if (out.indexOf(host[0]) === -1 && !host[0].startsWith('192.168.56')) {
        out.push(host[0]);
      }
    }
    return out;
  }
}
