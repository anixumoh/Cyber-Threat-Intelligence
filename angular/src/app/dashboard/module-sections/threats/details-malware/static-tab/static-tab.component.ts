import { Component, OnInit, Inject, forwardRef } from '@angular/core';
import { Subscription } from 'rxjs';

import { DetailsMalwareComponent } from '../details-malware.component';
import { isEmpty } from 'app/utils/functions';
import { StaticTabModel } from 'app/dashboard/module-sections/threats/details-malware/static-tab/static-tab.model';

let initTimeout;

@Component({
  selector: 'app-static-tab',
  templateUrl: './static-tab.component.html',
  styleUrls: ['./static-tab.component.scss'],
})
export class StaticTabComponent implements OnInit {
  contentChildPdfString: any;
  contentChildPdf: any;
  contentChild: any;
  compressedFileContents: any[];
  compile_time: any;
  sections: any;
  imports: any = {};
  dlls: any[] = [];
  listKeys: { name: string; key: string }[];
  changes: {};
  macros: {};
  hasMacros: boolean;
  eps: any;
  type: string;

  subscriptionsList: Subscription[] = [];
  resource: any = {};
  headerData: any[] = [[{ name: 'PACKER', value: 'packer' }], [{ name: 'YARA', value: 'yara' }]];

  constructor(@Inject(forwardRef(() => DetailsMalwareComponent)) private parentComponent: DetailsMalwareComponent) {}

  ngOnInit() {
    this.resource = new StaticTabModel();
    let s = this.parentComponent.staticTabResourceSubject.subscribe(res => {
      if (res != 'first') {
        if (res && !isEmpty(res)) {
          this.resource = JSON.parse(JSON.stringify(res));
        }
        this.setStaticTab();
      }
    });
    this.subscriptionsList.push(s);
  }

  ngOnDestroy() {
    this.unsubscribe();
  }

  unsubscribe() {
    this.subscriptionsList.forEach(subscription => {
      if (subscription.unsubscribe) {
        subscription.unsubscribe();
      }
    });
  }

  setStaticTab() {
    this.type = '';
    this.setResourceHeader();
    this.setStaticOrFile();
  }

  setResourceHeader() {
    this.resource.header = {
      packer: this.resource.blueliv && this.resource.blueliv.packer ? this.resource.blueliv.packer : '-',
      size: this.resource.fileSize ? this.resource.fileSize : '-',
      ssdeep:
        this.resource.target && this.resource.target.file && this.resource.target.file.ssdeep
          ? this.resource.target.file.ssdeep
          : '-',
      yara:
        this.resource.target &&
        this.resource.target.file &&
        this.resource.target.file.yara &&
        this.resource.target.file.yara.length
          ? this.resource.target.file.yara
              .map(e => {
                return e.name;
              })
              .join(', ')
          : '-',
    };
  }

  setStaticOrFile() {
    if (this.resource.static && Object.keys(this.resource.static).length > 0) {
      if (this.resource.static.office) {
        this.parseOffice();
      } else if (this.resource.static.pdf) {
        this.parsePdf();
      } else {
        this.parseExe();
      }
    } else if (this.resource.target && this.resource.target.file && this.resource.target.file.compressed_files) {
      this.parseZip();
    }
  }

  //TO-DO
  parseOffice() {
    this.type = 'office';
    this.eps = this.resource.static.office.eps;
    let macros = {};
    this.resource.static.office.macros.forEach(e => {
      macros[e.filename] = e;
    });
    this.hasMacros = this.resource.static.office.macros.length > 0 ? true : false;
    this.macros = macros;
  }

  parsePdf() {
    this.type = 'pdf';
    if (this.resource.static && this.resource.static.pdf) {
      if (this.resource.static.pdf.metadata) {
        let _pdf = this.resource.static.pdf.metadata;
        let changes = {};
        _pdf.forEach((e, key) => {
          if (e.creation != '') {
            changes[e.creation] = e;
          } else {
            changes[key + 1] = e;
          }
        });
        this.changes = changes;
        this.listKeys = [
          { name: 'Title', key: 'title' },
          { name: 'Subject', key: 'subject' },
          { name: 'Author', key: 'author' },
          { name: 'Creator', key: 'creator' },
          { name: 'Producer', key: 'producer' },
          { name: 'Version', key: 'version' },
        ];
      } else {
        this.contentChildPdfString = this.resource.static.pdf;
      }
    }
  }

  parseExe() {
    this.type = 'exe';
    let _static = this.resource.static;
    //this.isExe = true;
    _static.pe_imports.forEach(im => {
      let dll = im.dll;
      this.dlls.push(dll);
      this.imports[dll] = im.imports;
    });
    this.sections = _static.pe_sections;
    this.compile_time = _static.pe_timestamp;
  }

  parseZip() {
    this.type = 'zip';
    this.compressedFileContents = this.mapZipContents(this.resource.target.file.compressed_files);
  }

  mapZipContents(list) {
    let foldersHash = {};
    let firstLevel = [];
    let setToParent;
    setToParent = element => {
      let parentIndex = element.fullname.lastIndexOf('/');
      if (parentIndex && parentIndex > 0) {
        let path = element.fullname.substr(0, parentIndex);
        let parent = foldersHash[path];
        if (!parent) {
          parent = {
            type: 'folder',
            fullname: path,
            children: [],
          };
          setToParent(parent);
          foldersHash[path] = parent;
        }
        element.name = element.fullname.substr(parentIndex + 1);
        parent.children.push(element);
      } else {
        element.name = element.fullname;
        firstLevel.push(element);
      }
    };
    list
      .filter(e => {
        return e.md5 != null;
      })
      .forEach(e => {
        let data = {
          type: 'file',
          fullname: e.name,
          md5: e.md5,
          vtRatio: e.VirusTotal.detection_ratio,
          vtLink: e.VirusTotal.permalink,
          children: [],
        };
        if (e.compressed_files) {
          data.type = 'zip';
          this.mapZipContents(e.compressed_files).forEach(e => {
            data.children.push(e);
          });
        }
        setToParent(data);
      });
    return firstLevel;
  }

  selectImport(key: string) {
    this.contentChild = this.imports[key].filter(element => {
      return typeof element.name === 'string' && element.name.length > 0;
    });
  }

  selectMacros(key: string) {
    this.contentChild = this.macros[key];
  }

  selectPdf(key: string) {
    this.contentChildPdf = this.changes[key];
  }

  navigateToUrl(urlToOpen) {
    let url: string = '';
    if (!/^http[s]?:\/\//.test(urlToOpen)) {
      url += 'http://';
    }

    url += urlToOpen;
    window.open(url, '_blank');
  }
}
