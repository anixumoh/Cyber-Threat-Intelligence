import { Component, OnDestroy, OnInit } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { ISelectItem } from '../../../../shared/components/select/select.component';
import { MalwaresStore } from '../malwares-store';
import * as objHash from 'object-hash';

@Component({
  selector: 'app-malware-details-memory',
  templateUrl: './malware-details-memory.component.html',
  styleUrls: ['./malware-details-memory.component.scss'],
})
export class MalwareDetailsMemoryComponent implements OnInit, OnDestroy {
  items = [];
  loading = false;
  searchText = '';
  page = 0;
  count = 0;
  limit = 10;
  limits: ISelectItem[] = [
    { name: '10', value: 10 },
    { name: '15', value: 15 },
    { name: '20', value: 20 },
    { name: '30', value: 30 },
    { name: '50', value: 50 },
  ];
  tabs = [{ name: 'Info' }, { name: 'Yara' }, { name: 'Urls' }];
  activeTab = this.tabs[0];
  drawer = false;
  yara = [];
  public selectedItem: {};
  public memory: any;
  public subscription = null;
  public data = [];
  public events2Print = {
    malfind: {
      origin_name: 'Code Injection',
      cols: [
        { name: 'malware_type', title: 'Malware Type' },
        { name: 'process_id', title: 'PID' },
        { name: 'process_name', title: 'Process Name' },
        { name: 'vad_start', title: 'Start' },
        { name: 'vad_tag', title: 'Tag' },
      ],
    },
    yarascan: {
      origin_name: 'Yarascan',
      cols: [
        { name: 'owner', title: 'Owner' },
        { name: 'rule', title: 'Yara' },
        { name: 'hexdump', title: 'Hexdump' },
      ],
    },
    procmemory: {
      origin_name: 'Process Memory',
      cols: [
        { name: 'file', title: 'File' },
        { name: 'malware_type', title: 'Malware Type' },
        { name: 'pid', title: 'PID' },
      ],
    },
  };
  public blackListedYaras = [
    'CRC32_table',
    'MD5_Constants',
    'BASE64_table',
    'RIPEMD160_Constants',
    'VC8_Random',
    'MinGW',
    'DES_Long',
    'RijnDael_AES_CHAR',
    'RijnDael_AES_LONG',
    'MD5_API',
  ];
  private readonly destroy$ = new Subject<void>();

  constructor(private store: MalwaresStore) {}

  ngOnInit() {
    this.list();
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  mapYara(yara: any[]) {
    return yara.map((item) => {
      item.code = item.strings.join('<br/>');
      return item;
    });
  }

  reload() {
    this.page = 0;
    this.list();
  }

  onChangeLimit(item: ISelectItem) {
    this.limit = item.value;
    this.reload();
  }

  search() {
    this.reload();
  }

  onPageChange({ page }) {
    this.page = page;
    this.list();
  }

  list() {
    this.store.state$.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      if (value) {
        this.memory = {
          procmemory: value['procmemory'],
          memory: value['memory'],
        };
        this.prepareData();
      }
    });
  }

  private prepareData() {
    this.data = [];
    this.prepareProcMemDump();
    this.prepareVolatility();
  }

  private normalizeMemAttributes(item, origin_key) {
    let pid = '-';
    let match = [];
    let pname = '-';
    let sha256 = '-';
    let name = '-';
    let malware_type = '-';
    let hash_id = objHash.sha1(item);

    if (item.hasOwnProperty('sha256')) {
      sha256 = item['sha256'];
    }
    if (item.hasOwnProperty('malware_type')) {
      malware_type = item['malware_type'];
    }
    if (item.hasOwnProperty('rule')) {
      match = item['rule'].split(' ');
    }
    if (item.hasOwnProperty('yara')) {
      for (let i of item['yara']) {
        if (i.hasOwnProperty('rule')) {
          match.push(i['rule']);
        }
      }
    }
    if (item.hasOwnProperty('process_id')) {
      pid = item['process_id'];
    }
    if (item.hasOwnProperty('pid')) {
      pid = item['pid'];
    }
    if (item.hasOwnProperty('process_name')) {
      pname = item['process_name'];
    }
    if (item.hasOwnProperty('owner')) {
      const parts = item['owner'].split(' ');
      pname = parts.slice(1, parts.length - 2).join(' ');
      pid = parts[parts.length - 1];
    }
    if (item.hasOwnProperty('file_path')) {
      name = item['file_path'].split('/').pop();
    }
    if (item.hasOwnProperty('file')) {
      name = item['file'].split('/').pop();
    }
    let orig_name = '';
    if (this.events2Print.hasOwnProperty(origin_key)) {
      orig_name = this.events2Print[origin_key]['origin_name'];
    }
    return {
      pid: pid,
      match: match,
      process_name: pname,
      sha256: sha256,
      name: name,
      malware_type: malware_type,
      id: hash_id,
      origin: orig_name,
      origin_key: origin_key,
    };
  }

  private isBlacklisted(item) {
    if (item.match.length == 1) {
      if (item.match[0].split('_').pop() == 'ig') {
        return true;
      }
      for (let blyara of this.blackListedYaras) {
        if (blyara == item.match[0]) {
          return true;
        }
      }
    }
    return false;
  }

  private prepareVolatility() {
    let normalizedItem = {};
    if (this.memory.hasOwnProperty('memory')) {
      for (let volKey in this.memory['memory']) {
        if (this.events2Print.hasOwnProperty(volKey)) {
          for (let item of this.memory['memory'][volKey]['data']) {
            normalizedItem = this.normalizeMemAttributes(item, volKey);
            if (!this.isBlacklisted(normalizedItem)) {
              this.data.push(normalizedItem);
            }
          }
        }
      }
    }
  }

  private prepareProcMemDump() {
    let normalizedItem = {};
    if (this.memory.hasOwnProperty('procmemory') && this.memory.procmemory) {
      for (let item of this.memory['procmemory']) {
        normalizedItem = this.normalizeMemAttributes(item, 'procmemory');
        this.data.push(normalizedItem);
      }
    }
  }

  private getProcessMem(hash_id) {
    let indexp = 0;
    for (let p of this.memory['procmemory']) {
      let hid = objHash.sha1(p);
      if (hid == hash_id) {
        break;
      }
      indexp = indexp + 1;
    }
    return this.memory['procmemory'][indexp];
  }

  private getVolData(origin_key, hash_id) {
    let indexv = 0;
    let normalizedItem = {};

    for (let p of this.memory['memory'][origin_key]['data']) {
      normalizedItem = this.normalizeMemAttributes(p, origin_key);
      if (normalizedItem['id'] == hash_id) {
        break;
      }
      indexv = indexv + 1;
    }
    return this.memory['memory'][origin_key]['data'][indexv];
  }

  private getMemoryByID(origin_key, hash_id) {
    let memInfo = {};
    if (origin_key == 'procmemory') {
      memInfo = this.getProcessMem(hash_id);
    } else {
      memInfo = this.getVolData(origin_key, hash_id);
    }
    return memInfo;
  }

  private openDetails(origin_key, hash_id) {
    // Clone object to not modify the original one
    // since hash is based on it
    let tmp: any = { ...this.getMemoryByID(origin_key, hash_id) };
    tmp['type'] = 'memory';
    tmp['origin_key'] = origin_key;
    tmp['origin'] = this.events2Print[origin_key]['origin_name'];
    tmp['columns'] = this.events2Print[origin_key]['cols'];
    tmp.urls = tmp.urls || [];
    tmp.yara = this.mapYara(tmp.yara || []);
    this.selectedItem = tmp;
  }
}
