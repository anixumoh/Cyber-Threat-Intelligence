import { Subject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core';
import { MalwaresService } from '../../../core/models/malwares.service';

const downloadStatus = {
  pending: 'PENDING',
  received: 'RECEIVED',
  started: 'STARTED',
  success: 'SUCCESS',
  failure: 'FAILURE',
  revoked: 'REVOKED',
  retry: 'RETRY',
};

@Component({
  selector: 'request-download-malware-by-hash',
  templateUrl: './request-download-malware-by-hash.component.html',
  styleUrls: ['./request-download-malware-by-hash.component.scss'],
})
export class RequestDownloadMalwareByHashComponent implements OnInit, OnDestroy {
  @Input() hash: string;
  @Output() completed = new EventEmitter<boolean>();
  loading = false;
  clearTimeoutCallback;
  clearGeneralTimeoutCallback;
  private readonly destroy$ = new Subject<void>();

  constructor(private malwaresService: MalwaresService) {}

  ngOnInit(): void {
    this.requestDownloadByHash(this.hash);
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private requestDownloadByHash(hash: string) {
    this.loading = true;
    this.malwaresService
      .requestDownloadByHash(hash)
      .pipe(takeUntil(this.destroy$), take(1))
      .subscribe(
        (response) => {
          if (response && response.data) {
            if (response.data.task) {
              return this.runTask(response.data.task.id);
            }
          }
          this.loading = false;
        },
        (error) => {
          this.loading = false;
          this.completed.emit(false);
        }
      );
  }

  private runTask(taskId) {
    if (typeof this.clearGeneralTimeoutCallback === 'function') {
      try {
        this.clearGeneralTimeoutCallback();
      } catch (e) {
        console.log(e);
      }
    }
    this.clearGeneralTimeoutCallback = setTimeout(() => {
      this.completed.emit(false);
      if (typeof this.clearTimeoutCallback === 'function') {
        try {
          this.clearTimeoutCallback();
        } catch (e) {
          console.log(e);
        }
      }
    }, 120000);
    this.malwaresService
      .checkRequestDownloadTask(taskId)
      .pipe(takeUntil(this.destroy$), take(1))
      .subscribe((response) => {
        if (response && response.data) {
          const { state } = response.data;
          switch (state) {
            case downloadStatus.success:
              this.loading = false;
              this.completed.emit(true);
              break;
            case downloadStatus.failure:
            case downloadStatus.revoked:
              this.loading = false;
              this.completed.emit(false);
              break;
            case downloadStatus.pending:
            case downloadStatus.started:
            case downloadStatus.retry:
              this.clearTimeoutCallback = setTimeout(() => {
                this.runTask(taskId);
              }, 1000);
              break;
          }
        }
      });
  }
}
