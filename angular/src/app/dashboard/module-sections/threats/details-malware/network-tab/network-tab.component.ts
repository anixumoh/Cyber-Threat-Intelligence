import { Component, Inject, OnInit, forwardRef, OnDestroy, HostListener } from '@angular/core';
import { Subscription } from 'rxjs';

import { DetailsMalwareComponent } from '../details-malware.component';
import { getKey } from 'app/utils/get-key.pipe';
import { isEmpty } from 'app/utils/functions';
import { NetworkTabModel } from 'app/dashboard/module-sections/threats/details-malware/network-tab/network-tab.model';
import { InfiniteScrollModel } from 'app/dashboard/module-sections/shared/infinite-scroll/infinite-scroll.model';

@Component({
  selector: 'app-network-tab',
  templateUrl: './network-tab.component.html',
  styleUrls: ['./network-tab.component.scss'],
})
export class NetworkTabComponent implements OnInit, OnDestroy {
  dnsItems: any;
  domains: any;
  resource: any;
  isShow: string;
  httpItems: any[] = [];
  httpsItems: any[] = [];
  udpItems: any[] = [];
  tcpItems: any[] = [];
  infiniteScroll_num = 8;
  infiniteScroll_scrollPercent = 20;
  infiniteScroll_page = 0;
  infiniteScrollHttpItems: InfiniteScrollModel = new InfiniteScrollModel(
    this.httpItems,
    this.infiniteScroll_scrollPercent,
    this.infiniteScroll_num,
    this.infiniteScroll_page
  );
  infiniteScrollHttpsItems: InfiniteScrollModel = new InfiniteScrollModel(
    this.httpsItems,
    this.infiniteScroll_scrollPercent,
    this.infiniteScroll_num,
    this.infiniteScroll_page
  );
  infiniteScrollUdpItems: InfiniteScrollModel = new InfiniteScrollModel(
    this.udpItems,
    this.infiniteScroll_scrollPercent,
    this.infiniteScroll_num,
    this.infiniteScroll_page
  );
  infiniteScrollTcpItems: InfiniteScrollModel = new InfiniteScrollModel(
    this.tcpItems,
    this.infiniteScroll_scrollPercent,
    this.infiniteScroll_num,
    this.infiniteScroll_page
  );

  tabData: any = {};
  subscriptionsList: Subscription[] = [];

  http_s_TableHeader = [
    { value: 'Domain' },
    { value: 'IP', class: 'text-center' },
    { value: 'Request', class: 'text-center' },
    { value: 'Response', class: 'text-center' },
  ];

  tcpUdpTableHeader = [
    { value: 'Origin' },
    { value: 'Port', class: 'text-center' },
    { value: 'Destiny', class: 'text-center' },
    { value: 'Port', class: 'text-center' },
  ];

  dnsTableHeader = [
    { value: 'Name' },
    { value: 'Type', class: 'text-center' },
    { value: 'Response', class: 'text-center' },
  ];

  constructor(@Inject(forwardRef(() => DetailsMalwareComponent)) private parentComponent: DetailsMalwareComponent) {}

  ngOnInit() {
    this.tabsData();
    this.resource = new NetworkTabModel();
    let s = this.parentComponent.networkTabResourceSubject.subscribe((res) => {
      if (res !== 'first') {
        if (res && !isEmpty(res)) {
          this.resource = JSON.parse(JSON.stringify(res));
        }
        this.setNetworkTab();
      }
    });
    this.subscriptionsList.push(s);
  }

  ngOnDestroy() {
    this.unsubscribe();
  }

  unsubscribe() {
    this.subscriptionsList.forEach((subscription) => {
      if (subscription.unsubscribe) {
        subscription.unsubscribe();
      }
    });
  }

  setNetworkTab() {
    this.dnsItems = this.resource.dns;
    this.setDNSItems();
    this.tcpItems = this.resource.tcp;
    this.setTCPItems();
    this.udpItems = this.resource.udp;
    this.setUDPItems();
    this.domains = this.resource.domains;
    this.httpItems = this.resource.http_ex ? this.resource.http_ex : [];
    this.setHTTP_S_Items('http');
    this.httpsItems = this.resource.https_ex ? this.resource.https_ex : [];
    this.setHTTP_S_Items('http');
  }

  tabsData() {
    this.setTabData();
    this.isShow = 'HTTP';
  }

  setTabData() {
    this.tabData = {
      HTTP: {},
      HTTPS: {},
      TCP: {},
      UDP: {},
    };
  }

  selectImport(key: string) {
    this.isShow = key;
  }

  setDNSItems() {
    if (this.dnsItems) {
      this.dnsItems.forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.request ? it.request : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.type ? it.type : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: (() => {
              return it.answers.map((ans) => {
                return `${ans.data ? ans.data : '-'} : ${ans.type ? ans.type : '-'}`;
              });
            })(),
            isArray: it.answers ? true : false,
            class: 'td-center',
          },
        ];
      });
    }
  }

  setTCPItems() {
    if (this.tcpItems) {
      this.tcpItems.forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.src ? it.src : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.sport ? it.sport : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.dst ? it.dst : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.dport ? it.dport : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
        ];
      });
      this.infiniteScrollTcpItems = new InfiniteScrollModel(
        this.tcpItems,
        this.infiniteScroll_scrollPercent,
        this.infiniteScroll_num,
        this.infiniteScroll_page
      );
    }
  }

  setUDPItems() {
    if (this.udpItems) {
      this.udpItems.forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.src ? it.src : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.sport ? it.sport : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.dst ? it.dst : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.dport ? it.dport : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
        ];
      });
      this.infiniteScrollUdpItems = new InfiniteScrollModel(
        this.udpItems,
        this.infiniteScroll_scrollPercent,
        this.infiniteScroll_num,
        this.infiniteScroll_page
      );
    }
  }

  setHTTP_S_Items(type) {
    if ((type == 'http' && this.httpItems) || (type == 'https' && this.httpsItems)) {
      (type == 'http' ? this.httpItems : this.httpsItems).forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.host ? it.host : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: this.setIp(it.host),
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.request ? it.request : '-',
            isModal: true,
            modalTitle: 'Request',
            isOpen: false,
            class: 'td-center',
          },
          {
            value: it.response ? it.response : '-',
            isModal: true,
            modalTitle: 'Response',
            isOpen: false,
            class: 'td-center',
          },
        ];
      });
      if (type === 'http') {
        this.infiniteScrollHttpItems = new InfiniteScrollModel(
          this.httpItems,
          this.infiniteScroll_scrollPercent,
          this.infiniteScroll_num,
          this.infiniteScroll_page
        );
      } else {
        this.infiniteScrollHttpsItems = new InfiniteScrollModel(
          this.httpsItems,
          this.infiniteScroll_scrollPercent,
          this.infiniteScroll_num,
          this.infiniteScroll_page
        );
      }
    }
  }

  setIp(domain) {
    let tempDomain = this.domains.find((element) => {
      return element.domain === domain;
    });
    return tempDomain ? tempDomain.ip : '-';
  }

  @HostListener('scroll', ['$event'])
  onScroll(event, fn, obj) {
    fn.call(obj, event);
  }
}
