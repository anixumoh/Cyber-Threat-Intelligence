import { Component, OnInit, Inject, forwardRef, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
import * as _ from 'lodash';

import { MalwareDynamicsService } from '../malware-dynamics.service';
import { DetailsMalwareComponent } from '../details-malware.component';
import { isEmpty } from 'app/utils/functions';
import { DynamicTabModel } from 'app/dashboard/module-sections/threats/details-malware/dynamic-tab/dynamic-tab.model';
@Component({
  selector: 'app-dynamic-tab',
  templateUrl: './dynamic-tab.component.html',
  styleUrls: ['./dynamic-tab.component.scss'],
})
export class DynamicTabComponent implements OnInit, OnDestroy {
  isPresent: boolean;
  timeOutReference: any;
  loading = false;
  stopper = false;

  dropped: any[];
  extraDropped: any[];
  showMoreOpened = false;
  reportVersion: string;
  resource: any;
  firstLevel: any[];
  hash: any;
  hasGraph = false;
  hasData = false;
  cuckooVersion: string;
  behavior: any;
  droppedPre: any[];

  subscriptionsList: Subscription[] = [];

  constructor(
    @Inject(forwardRef(() => DetailsMalwareComponent)) private parentComponent: DetailsMalwareComponent,
    private malwareDynamicsService: MalwareDynamicsService
  ) {
    this.firstLevel = [];
    this.hash = {};
  }

  ngOnInit() {
    this.resource = new DynamicTabModel();
    let s = this.parentComponent.dynamicTabResourceSubject.subscribe((res) => {
      if (res != 'first' && !this.stopper) {
        if (res && !isEmpty(res)) {
          this.resource = JSON.parse(JSON.stringify(res));
          this.isPresent = true;
        }
        this.loading = false;
        this.setDynamicTab();
      }
    });

    let s2 = this.parentComponent.timeOutSubject.subscribe((res) => {
      if (res == 'stopper') {
        if (this.timeOutReference) {
          clearTimeout(this.timeOutReference);
        }
        if (!this.isPresent) {
          this.loading = true;
          this.stopper = false;
          this.timeOutReference = setTimeout(() => {
            this.loading = false;
            this.stopper = true;
            clearTimeout(this.timeOutReference);
          }, 120000);
        } else {
          this.isPresent = false;
        }
      }
    });

    this.subscriptionsList.push(s);
    this.subscriptionsList.push(s2);
  }

  ngOnDestroy() {
    this.unsubscribe();
  }

  unsubscribe() {
    this.subscriptionsList.forEach((subscription) => {
      if (subscription.unsubscribe) {
        subscription.unsubscribe();
      }
    });
  }

  setDynamicTab() {
    this.malwareDynamicsService.deselect();
    this.cuckooVersion = this.resource.cuckooVersion ? this.resource.cuckooVersion : '';
    this.droppedPre = this.resource.dropped ? this.resource.dropped : [];
    this.behavior = this.resource.behavior ? this.resource.behavior : {};
    this.manageDropped();
    if (!isEmpty(this.behavior)) {
      if (this.cuckooVersion == '1.0') {
        this.genericProcessV1();
      } else {
        this.genericProcessV2();
      }
      var processSize = this.behavior.processes.length;
      var levelsSize = this.getCallLevels(this.firstLevel, 0);
      this.hasGraph = processSize < 15 || levelsSize <= 4;
    }
    this.hasData = this.firstLevel.length > 0 || this.dropped.length > 0;
  }

  getCallLevels(list, level) {
    var maxLevel = level;
    list.forEach((e) => {
      var newLevels = this.getCallLevels(e.children, level + 1);
      if (maxLevel < newLevels) {
        maxLevel = newLevels;
      }
    });
    return maxLevel;
  }

  genericProcessV1() {
    this.firstLevel = [];
    this.behavior.processes.forEach((process) => {
      this.hash[process.process_id] = process;
      process.children = [];
      process.pid = process.process_id;
    });

    this.behavior.processes.forEach((process) => {
      var process_id = process.process_id;
      var parent = this.hash[process.parent_id];
      var elem = this.hash[process_id];
      if (parent) {
        parent.children.push(elem);
      } else {
        this.firstLevel.push(elem);
      }
      elem.summary = {};
      elem.summary.apistats = [];
    });
    this.behavior.processes.forEach((e) => {
      if (!e.summary) {
        e.summary = {
          children: [],
        };
      }
      e.summary.children = e.children.map((e) => {
        return e.process_id + '>' + e.process_name;
      });
      e.firstSeen = new Date(e.first_seen.replace(',', '.')).toISOString();
    });
  }

  genericProcessV2() {
    this.firstLevel = [];
    this.behavior.processes.forEach((process) => {
      this.hash[process.pid] = process;
      process.children = [];
    });
    if (!this.behavior.generic) {
      this.behavior.generic = [];
    }
    this.behavior.generic.forEach((process) => {
      var pid = process.pid;
      var parent = this.hash[process.ppid];
      var elem = this.hash[pid];
      if (elem) {
        if (parent) {
          parent.children.push(elem);
        } else {
          this.firstLevel.push(elem);
        }

        elem.malware_type = process.malware_type;

        elem.summary = process.summary;
        var objApiStats = this.behavior.apistats[pid];
        if (objApiStats) {
          var apiStats = Object.keys(objApiStats).map((key) => {
            return key + ':' + objApiStats[key];
          });
          elem.summary.apistats = apiStats;
        } else {
          elem.summary.apistats = [];
        }
      }
    });
    this.behavior.processes.forEach((e) => {
      if (!e.summary) {
        e.summary = {
          children: [],
        };
      }
      e.summary.children = e.children.map((e) => {
        return e.pid + '>' + e.process_name;
      });
      if (typeof e.first_seen == 'string') {
        e.firstSeen = Date.parse(e.first_seen.split(',')[0]);
      } else {
        e.firstSeen = new Date(e.first_seen * 1000).toISOString();
      }
    });
  }

  manageDropped() {
    if (this.droppedPre == null) {
      this.droppedPre = [];
    }
    var malicious = [];
    var suspicious = [];
    var nonMalicious = [];
    this.droppedPre.forEach((item, i) => {
      if (item.malware_type) {
        if (item.malware_type == 'UNCLASSIFIED') {
          suspicious.push(item);
          item.kind = 'suspicious';
        } else {
          malicious.push(item);
          item.kind = 'malicious';
        }
      } else {
        nonMalicious.push(item);
        item.kind = '';
      }
      this.hash[item.sha1] = item;
      if (item.content != '[!] Omitting remaining dropped files content') {
        item.strings = item.content.split('\n');
      }
      var vt = item.virustotal;
      if (vt && vt.summary.detection_ratio) {
        item.virusTotal = vt.summary.detection_ratio;
      }
    });

    this.dropped = malicious.concat(suspicious).concat(nonMalicious).slice(0, 2);
    this.extraDropped = malicious.concat(suspicious).concat(nonMalicious).slice(2);
  }

  toogleShowMore() {
    this.showMoreOpened = !this.showMoreOpened;
  }

  openContent(file) {
    this.malwareDynamicsService.select('file', file);
  }

  openProcess(node) {
    this.malwareDynamicsService.select('process', node);
  }

  getDepth(obj) {
    var depth = 0;
    if (obj.children) {
      obj.children.forEach((d) => {
        var tmpDepth = this.getDepth(d);
        if (tmpDepth > depth) {
          depth = tmpDepth;
        }
      });
    }
    return 1 + depth;
  }
}
