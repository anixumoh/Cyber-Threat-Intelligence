import { Component, OnInit, Input, Output, EventEmitter, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Timeline } from '../../../../../shared/components/timeline/timeline.cs';
import { MalwareSourcesStore } from '../../malware-sources-store';
import * as moment from 'moment';

@Component({
  selector: 'app-malware-details-summary-sources',
  template: `
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">Sources</h5>
      </div>
      <div class="card-block timeline-container">
        <ng-container *ngIf="sources && sources.length > 0">
          <app-timeline [moduleId]="moduleId" [orgId]="orgId" [timelineData]="sources"> </app-timeline>
        </ng-container>
        <!-- NO RESULTS DATA -->
        <ng-container *ngIf="!sources || sources.length <= 0">
          <div class="no-results-box bg-light">
            <img src="/assets/default_images/searching.svg" />
            <h4 class="no-results">No sources have been identified</h4>
          </div>
        </ng-container>
      </div>
    </div>
  `,
  styleUrls: ['./malware-details-summary-sources.component.scss'],
})
export class MalwareDetailsSummarySourcesComponent implements OnInit, OnDestroy {
  @Input() orgId;
  @Input() moduleId;
  @Output() seenDates = new EventEmitter();
  sources: Timeline[] = [];
  private readonly destroy$ = new Subject<void>();

  constructor(private store: MalwareSourcesStore) {}

  ngOnInit() {
    this.store.state$.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      if (value) {
        this.sources = value.map((item) => {
          const date = item.attributes.created_at
            ? moment(item.attributes.created_at).format('DD/MM/YYYY HH:mm (Z)')
            : '';
          return new Timeline(item.attributes.name, date, item.attributes.keyword);
        });
        this.getSeenDates(
          value
            .filter((item) => !!item)
            .map((item) => {
              const date = item.attributes.first_seen;
              if (!date) {
                return false;
              }
              return moment(date);
            })
        );
      }
    });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private getSeenDates(dates) {
    if (dates && dates.length > 0) {
      let firstSeen = '';
      let lastSeen = '';
      for (const date of dates) {
        if ((!firstSeen && date) || (date && firstSeen > date)) {
          firstSeen = date;
        }
        if ((!lastSeen && date) || (date && lastSeen < date)) {
          lastSeen = date;
        }
      }
      this.seenDates.emit({ firstSeen, lastSeen });
    }
  }
}
