import { Component, OnDestroy, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Subject } from 'rxjs';
import { take, filter, takeUntil } from 'rxjs/operators';

import {
  capitalize,
  isStringsDict,
  isStringsArray,
  isComposedDict,
} from './render_components/render_components.functions';
import { MalwaresStore } from '../malwares-store';
import { ioaMetaCount } from './ioa.symbols';

@Component({
  selector: 'app-malware-details-ioa',
  templateUrl: './ioa.component.html',
  styleUrls: ['./ioa.component.scss'],
})
export class MalwareIOA implements OnInit, OnDestroy {
  ioa;
  metaCountField = ioaMetaCount;
  private stringArrayKeys = ['ip', 'domain', 'email', 'host', 'mutex', 'process_name', 'registry', 'url'];
  private stringDictKeys: string[] = [];
  private composedDictKeys = ['connections', 'metadata', 'regkeys', 'yara', 'metadata', 'ports', 'path'];
  private readonly destroy$ = new Subject<void>();

  constructor(private store: MalwaresStore, private route: ActivatedRoute) {}

  ngOnInit() {
    const ioaActiveSection = this.route.snapshot.queryParams['ioaActiveSection'];
    this.store.state$
      .pipe(
        takeUntil(this.destroy$),
        filter((item) => !!item),
        take(1)
      )
      .subscribe((data) => {
        if (data && data.blueliv) {
          const ioaAux = data.blueliv.ioa;
          const { attack_patterns, certificates, ...ioa } = ioaAux;

          for (const key in ioa) {
            if (ioa[key]) {
              const count = this.getCountByKey(ioa[key]);
              if (count === 0) {
                delete ioa[key];
              } else {
                ioa[key][this.metaCountField] = count;
              }
            }
          }

          this.ioa = this.iterable(ioa);
          if (ioaActiveSection && ioa[ioaActiveSection]) {
            const selectedElement = this.ioa.find((item) => item.key === ioaActiveSection);
            if (selectedElement) {
              selectedElement.accordionOpen = true;
            }
          }
        }
      });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  clickAccordion(element) {
    element.accordionOpen = !!!element.accordionOpen;
  }

  // a recursive function easy to learn
  getCountByKey(item) {
    let count = 0;
    // if item is undefined return 0;
    const itemType = typeof item;
    if (item) {
      if (Array.isArray(item)) {
        // if item is an array return array.lenght
        count = item.length;
      } else if (itemType === 'string' || itemType === 'number' || itemType === 'boolean') {
        // if item is a scalar type return 1; note: 'function' and 'symbol' not be count.
        count = 1;
      } else {
        if (itemType === 'object') {
          // if item is an object call recursive function for each keys
          for (const key in item) {
            if (item[key]) {
              const auxCount = this.getCountByKey(item[key]);
              if (auxCount === 0) {
                delete item[key];
              } else {
                if (typeof item[key] === 'object') {
                  item[key][this.metaCountField] = auxCount;
                }
                count += auxCount;
              }
            } else {
              delete item[key];
            }
          }
        }
      }
    }
    return count;
  }

  hasIOA() {
    return this.ioa;
  }

  ioa_capitalize(text) {
    return capitalize(text);
  }

  ioa_isStringsDict(key, value, inArray) {
    return isStringsDict(key, value, inArray);
  }

  ioa_isStringsArray(key, value, inArray) {
    return isStringsArray(key, value, inArray);
  }

  ioa_isComposedDict(key, value, inArray) {
    return isComposedDict(key, value, inArray);
  }

  private iterable(iterable: any): any[] {
    const result = [];
    if (iterable == null) {
      return result;
    }
    if (iterable.entries) {
      iterable.forEach((value, key) => {
        result.push({ key, value });
      });
    } else {
      for (const key in iterable) {
        if (iterable.hasOwnProperty(key)) {
          const value = iterable[key];
          const item = { key, value };
          item['count'] = iterable[key][this.metaCountField];
          result.push(item);
        }
      }
    }
    return result;
  }
}
