import { Component, OnDestroy, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Subject } from 'rxjs';
import { finalize, take, takeUntil } from 'rxjs/operators';
import { ISelectItem } from '../../../shared/components/select/select.component';
import { MalwaresService } from '../../../core/models/malwares.service';
import { OrganizationService } from '../../../dashboard/organization/organization.service';
import {
  extractPosibleHashFromQueryParams,
  isHash,
  isMD5,
  isSHA1,
  isSHA256,
  isSHA512
} from '../../../shared/utils/hash.utils';
import { ToastrService } from 'ngx-toastr';
import { ModuleModel, OrganizationModel } from 'app/dashboard/organization/models';
import { NewTabService } from 'app/services/new-tab.service';
import { IQuickFilter } from '../../../shared/components/tcx-quick-filters/tcx-quick-filters.component';
import { convertToCSV, copyToClipboard, exportClientFile } from '../../../utils/functions';
import moment from 'moment';
import { UserAccountService } from 'app/dashboard/user/account.service';

const uiDownloadingByHashState = {
  listing: 'listing',
  downlading: 'downlading',
  indexing: 'indexing'
};

@Component({
  selector: 'app-malwares-list-all',
  templateUrl: './malwares-list-all.component.html',
  styleUrls: ['./malwares-list-all.component.scss']
})
export class MalwaresListAllComponent implements OnInit, OnDestroy {
  items: any = [];
  loading = false;
  searchText = '';
  showModal = false;
  lastItem;
  openModalDorks = false;
  malwareHashToDownload: string;
  downloadingByHashState = uiDownloadingByHashState.listing;
  uiDownloadingByHashState = uiDownloadingByHashState;
  dorkFields = [];
  showSaveSearchButton = false;
  page = 0;
  count = 0;
  totalResources = 0;
  limit = 50;
  limits: ISelectItem[] = [
    { name: '10', value: 10 },
    { name: '15', value: 15 },
    { name: '20', value: 20 },
    { name: '30', value: 30 },
    { name: '50', value: 50 }
  ];
  activeModule: ModuleModel;
  listError = '';
  bulk = false;
  activeOrganization: OrganizationModel;
  currentYear = new Date().getFullYear();
  quickFilters: IQuickFilter[] = [
    {
      title: 'Malware by Type',
      filters: [
        { name: 'Emotet', dork: 'type:"EMOTET4" and num_properties:>0' },
        { name: 'Dridex', dork: 'type:"DRIDEX" and num_properties:>0' },
        { name: 'Trickbot', dork: 'type:"TRICKBOT" and num_properties:>0' },
        { name: 'BitPaymer', dork: 'type:"BITPAYMER"' },
        { name: 'Ryuk', dork: 'type:"RYUK" and num_properties:>0' },
        { name: 'AZORult', dork: 'type:"AZORULT" and num_properties:>0' },
        { name: 'HawkEye', dork: 'type:"HAWKEYE" and num_properties:>0' },
        { name: 'Oski', dork: 'type:"OSKI" and num_properties:>0' },
        { name: 'POS Malware', dork: 'type:~"POS" and num_properties:>0' }
      ]
    },
    {
      title: 'Hunting filters',
      filters: [
        {
          name: 'Malware classified by Blueliv',
          dork: 'NOT type:"UNCLASSIFIED" and NOT subtype:"VirusTotal" and status:"FINISHED_SUCCESSFULLY"'
        },
        {
          name: `Malware compiled in ${this.currentYear}`,
          dork: `ioa.metadata.pe_timestamp:^"${this.currentYear}"`
        },
        {
          name: `Malware signed in ${this.currentYear}`,
          dork: `ioa.metadata.signing_date:^"${this.currentYear}"`
        },
        {
          name: 'Malware using Sandbox evasion',
          dork: 'ioa.attack_patterns.name.keyword:"Virtualization/Sandbox Evasion"'
        },
        {
          name: 'Malware containing PDB paths',
          dork: 'ioa.path.pdb_path:$".pdb"'
        },
        {
          name: 'Malware using exploits',
          dork: 'cve:^"CVE-"'
        },
        {
          name: 'Malware connecting to a PHP URL',
          dork: 'ioa.url:$".php"'
        }
      ]
    }
  ];
  private statusValues = {
    FINISHED_SUCCESSFULLY: 'icon-check text-success',
    QUEUED: 'icon-cloud-solid',
    FINISHED_ERRONEOUSLY: 'icon-error text-danger',
    DISCARDED: 'icon-close text-danger',
    DELIVERED: 'icon-hourglass-start',
    SINKHOLED: 'icon-wifi text-primary',
    ONLINE: 'icon-wifi text-success',
    OFFLINE: 'icon-wifi text-danger'
  };
  private readonly destroy$ = new Subject<void>();

  constructor(
    private malwaresService: MalwaresService,
    private route: ActivatedRoute,
    private organizationService: OrganizationService,
    private toastrService: ToastrService,
    private newTabService: NewTabService,
    private accountService: UserAccountService
  ) {}

  ngOnInit() {
    this.loading = true;
    this.organizationService
      .getCurrentContext()
      .pipe(takeUntil(this.destroy$), take(1))
      .subscribe((context) => {
        this.activeModule = context.currentModule;
        this.activeOrganization = context.currentOrganization;
      });

    const { dork } = this.route.snapshot.queryParams;
    this.searchText = dork ? dork : 'status:"FINISHED_SUCCESSFULLY"';

    this.malwaresService
      .getMalwareOptionsFromThiapp()
      .pipe(takeUntil(this.destroy$), take(1))
      .subscribe(({ data }) => {
        if (data) {
          this.dorkFields = this.improveDorks(data.dork_fields);
        }
        this.loadSavedSearches();
        this.reloadData();
      });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  loadSavedSearches() {
    this.accountService.getSaveDorks('malwareHunting', this.quickFilters);

    const savedFilters = this.quickFilters.find((quick: IQuickFilter) => quick.title === 'Saved searches');
    if (savedFilters) {
      const defaultFilter = savedFilters?.filters.find((filter) => filter?.markAsDefault);
      if (defaultFilter) {
        this.searchText = defaultFilter?.dork;
      }
    }
  }

  hasSomeChecked() {
    return this.items.some((item) => item.fxSelected);
  }

  setCheckedState(event) {
    this.items = this.items.map((item) => ({ ...item, fxSelected: event.target.checked }));
  }

  setChecked() {
    setTimeout(() => {
      this.bulk = this.getCheckedItems().length === this.items.length;
    });
  }

  join(data, char) {
    return data.join(char);
  }

  onChangeQuickFilter(filter) {
    this.searchText = filter.dork;
    this.search();
  }

  score(value) {
    const defaultValue =
      ((typeof value === 'undefined' || value === 0 || Number.isNaN(value)) && 'N/A') ||
      ((value === null || typeof value !== 'number') && '-');
    return defaultValue || Math.round(value * 100);
  }

  improveDorks(dorks) {
    for (const key in dorks) {
      if (dorks.hasOwnProperty(key)) {
        switch (key) {
          case 'file_type':
            dorks[
              key
            ].description = `The file type of the malware sample. Options: PE | PE.DLL | MS-DOS| ELF.X86 | ELF.X64 | OFFICE | PDF | JAR | ZIP`;
            break;
          case 'source_name':
            dorks[
              key
            ].description = `The name of the source where the sample is coming from (case sensitive). Example: <span class="set-dork-example">source_name:~"Panda"</span>`;
            break;
          case 'status':
            dorks[
              key
            ].description = `The status of the sample. It shows if it is waiting to be analyzed, sent already to the sandbox or finished successfully. The user wonâ€™t be able to see the malware details until the sandbox analyzes the malware. Options: FINISHED_SUCCESSFULLY | QUEUED | DISCARDED | FINISHED_ERRONEOUSLY | DELIVERED | BLACKLISTED.`;
            break;
          case 'has_network':
            dorks[
              key
            ].description = `It defines if the sample generated network traffic during the analysis or not. Example: <span class="set-dork-example">has_network:1</span>.`;
            break;
          case 'has_c_and_c':
            dorks[
              key
            ].description = `Specifies if C2s were extracted from the analysis thanks to reversing efforts. Example: <span class="set-dork-example">has_c_and_c:1</span>.`;
            break;
          case 'has_other_urls':
            dorks[
              key
            ].description = `This field helps to find samples which generated additional URLs spotted during the analysis, like binary download URLs, for instance. Example: <span class="set-dork-example">has_other_urls:1</span>.`;
            break;
          case 'num_properties':
            dorks[
              key
            ].description = `Number of properties or metadata elements extracted from the analysis of the sample. These properties are extracted thanks to reversing efforts. Example: <span class="set-dork-example">num_properties:>3</span>.`;
            break;
          case 'first_seen':
            dorks[
              key
            ].description = `The first time we saw the sample from any of our sources. Example: <span class="set-dork-example">first_seen:>${this.currentYear}-01-01</span>`;
            break;
          case 'last_seen':
            dorks[
              key
            ].description = `The last time we saw the sample from any of our sources. Example: <span class="set-dork-example">last_seen:<${this.currentYear}-07-01</span>`;
            break;
          case 'type':
            dorks[
              key
            ].description = `Malware family classified by Blueliv or Virus Total, in some cases. Capital letters are mandatory for malware types and the use of operator ~ is recommended. Example: <span class="set-dork-example">type:~"LOKI"</span>.`;
            break;
          case 'score':
            dorks[key].description =
              'Maliciousness score based on Machine Learning algorithms (0-1 values). Example: <span class="set-dork-example">score:>0.9</span>';
            break;
          case 'vt_match':
            dorks[
              key
            ].description = `A TOP of the most repeated classifications by Virus Total engines (lower case). Example: <span class="set-dork-example">vt_match:"ryuk"</span>.`;
            break;
          case 'version':
            dorks[key].description =
              'It is the version number of the malware sample, when it is available. Example: <span class="set-dork-example">version:"3.3"</span>';
            break;
          case 'subtype':
            dorks[
              key
            ].description = `Subtype of the malware family. Helpful to find specific releases of the same malware family but also to find if the malware was classified by Blueliv or Virus Total. Examples: <span class="set-dork-example">subtype:"VirusTotal"</span> <span class="set-dork-example">subtype:"reborn"</span>`;
            break;
          case 'signatures':
            dorks[key].description =
              'High-level behavior detected by the sandbox and defined in the "Signatures" tab in the malware analysis detail. Example: <span class="set-dork-example">signatures:"Detects the presence of a Debugger"</span>';
            break;
          case 'cve':
            dorks[key].description =
              'Finds malware samples classified with a CVE name. Example: <span class="set-dork-example">cve:"CVE-2017-0199"</span>';
            break;
          case 'ioa':
            dorks[key].description =
              'The Indicators of Actors (IOA) is a Blueliv term to define any specific behavior of the malware sample during the analysis. See the <a\n' +
              '              href="/assets/pdf/Blueliv_Threat_Context_MalwareHunting_IOA_AdvancedSearch.pdf"\n' +
              '              target="_blank"\n' +
              '              style="text-decoration: none"\n' +
              '              class="btn-link"\n' +
              '            >advanced search manual</a> for all available options. Example: <span class="set-dork-example">ioa.attack_patterns.name.keyword:"Steal Web Session Cookie"</span>';
            break;
          case 'properties':
            dorks[key].description =
              'This dork allows searching all the metadata extracted thanks to reversing efforts. We can search here for encryption keys, botnet names or ids, malware targets, etc. Examples: <span class="set-dork-example">properties.properties.value.keyword:~"bank"</span> <span class="set-dork-example">properties.properties.value.keyword:"gtag"</span>';
            break;
          case 'md5':
          case 'sha1':
          case 'sha256':
          case 'sha512':
            dorks[key].description = `${key.toUpperCase()} hash`;
            break;
        }
      }
    }
    delete dorks.id;
    delete dorks.behavior;
    delete dorks.source_keyword;
    return dorks;
  }

  setDork(dork) {
    this.openModalDorks = false;
    this.searchText = dork;
    this.search();
  }

  reload() {
    this.page = 0;
    this.reloadData();
  }

  onChangeLimit(item: ISelectItem) {
    this.limit = item.value;
    this.reloadData();
  }

  search() {
    this.downloadingByHashState = uiDownloadingByHashState.listing;
    this.reload();
    this.showSaveSearchButton = true;
  }

  onPageChange({ page }) {
    this.page = page;
    this.reloadData();
  }

  onMalwareDownloadComplete(status: boolean) {
    if (status) {
      this.toastrService.success('Hash has been successfully process', 'Success ');
      this.downloadingByHashState = uiDownloadingByHashState.indexing;
      setTimeout(() => {
        this.reloadData();
      }, 3000);
    } else {
      this.toastrService.error('Error proccesing the hash', 'Failed');
      this.downloadingByHashState = uiDownloadingByHashState.listing;
    }
  }

  copyToClipboard(key = 'sha256') {
    const items = this.getCheckedItems();
    if (items && items.length > 0) {
      let clipboard = '';
      for (const item of items) {
        if (key === '*') {
          clipboard += `${item.attributes['md5']},${item.attributes['sha1']},${item.attributes['sha256']}` + '\r\n';
        } else {
          clipboard += item.attributes[key] + '\r\n';
        }
      }
      copyToClipboard(clipboard);
    }
  }

  exportToCSV() {
    const items = this.getExportableData(this.getCheckedItems());
    exportClientFile(convertToCSV(items), 'malware_hunting');
  }

  exportToJson() {
    const items = this.getExportableData(this.getCheckedItems());
    exportClientFile(JSON.stringify(items), 'malware_hunting', 'json');
  }

  hideSaveSearchButton() {
    const savedFilters = this.quickFilters.find((quick: IQuickFilter) => quick.title === 'Saved searches');
    if (savedFilters) {
      const filter = savedFilters?.filters.find((filter) => filter?.dork === this.searchText);
      if (!filter) {
        this.showSaveSearchButton = false;
      }
    }
  }

  onSetSearchTerm($event) {
    this.searchText = $event;
    this.hideSaveSearchButton();
  }

  onClearSearchTerm() {
    this.searchText = '';
    this.search();
  }

  onOpenModalDorks(value: boolean) {
    this.openModalDorks = value;
  }

  navigateToDetail(event, item) {
    if (event.target.type === 'checkbox' || event.target.className.includes('icon-copy')) {
      return;
    }
    if (!item.hasDetails) {
      const message = this.getStatusMessage(item.attributes.analysis_status);
      if (message) {
        this.toastrService.warning(message, 'No malware details');
      }
      return;
    }
    if (item.id) {
      const url = `/dashboard/organizations/${this.activeOrganization.id}/modules/${this.activeModule.id}/threat_context/malwares/${item.attributes.sha256}/summary`;
      this.newTabService.openNewTab(event, url, { dork: this.searchText });
    }
  }

  getStatusMessage(status) {
    switch (status) {
      case 'QUEUED':
        return 'This file is in the sandbox queue, the malware report will be available soon.';
      case 'DISCARDED':
      case 'BLACKLISTED':
      case 'UNKNOWN':
        return 'The malware report is not available for this sample.';
    }
    return '';
  }

  private getCheckedItems() {
    return this.items.filter((item) => item.fxSelected);
  }

  private getExportableData(items) {
    return items.map((item) => {
      return {
        'FIRST SEEN': moment(item.attributes.first_seen, 'YYYY-MM-DD[T]HH:mm:ss').format('DD/MM/YYYY'),
        SHA256: item.attributes.sha256,
        SCORE: this.score(item.attributes.cerberus),
        SOURCES: item.attributes.sources_representation.join(', '),
        TYPE: item.attributes.types_names.join(', '),
        STATUS: item.attributes.analysis_status || ' ',
        '#PROP': item.attributes.number_properties,
        NET: item.attributes.has_network,
        'C&C': item.attributes.has_c_and_c,
        URLS: item.attributes.has_other_urls,
        'File Type': item.attributes.file_type || ' '
      };
    });
  }

  checkSearchCriteriaHasDorks() {
    const currentDorks = Object.keys(this.dorkFields);
    return currentDorks.some((dork) => {
      const regexp2 = new RegExp(`(${dork})(\\.\\w+)*\\:.*`, 'g');
      return regexp2.test(this.searchText);
    });
  }

  private reloadData() {
    let params: any = { limit: this.limit, page: this.page };
    let hashToDownload: string = null;
    if (this.searchText) {
      // test if searchText is dork like
      if (this.checkSearchCriteriaHasDorks()) {
        params = { ...params, ...{ dork: this.searchText } };
      } else {
        const text = this.searchText.replace(/[\s|;,\n\r]+/g, ',');
        if (text.includes(',')) {
          const newDork = this.limitDorkToBeSentByHttpGet(this.processSearchText(text));
          params = { ...params, ...{ dork: newDork.value } };
          this.searchText = newDork.value;
          if (newDork.lastItem) {
            this.lastItem = newDork.lastItem;
            this.showModal = true;
          }
        } else if (isHash(this.searchText)) {
          // test if searchText is a hash
          params = {
            ...params,
            ...{
              filterValue: this.searchText,
              filterField: this.getSearchKey(this.searchText)
            }
          };
        } else {
          // if searchText isn't a hash then build a dork to look for type in upper case.
          params = { ...params, ...{ dork: `type:~"${this.searchText.toUpperCase()}"` } };
        }
      }
    }
    hashToDownload = extractPosibleHashFromQueryParams(params);
    this.loading = true;
    this.listError = '';
    this.malwaresService
      .fullList(params)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => (this.loading = false)),
        take(1)
      )
      .subscribe(
        ({ data, meta }) => {
          if (data) {
            this.bulk = false;
            this.items = data.map((item) => {
              if (item && item.attributes) {
                item.statusIconClass = this.getStatusIcon(item.attributes.analysis_status);
                item.hasDetails = this.checkStatusForDetails(item.attributes.analysis_status);
                if (!item.attributes?.cerberus) {
                  switch (item.attributes.malicious_category) {
                    case 1: {
                      item.attributes.cerberus = 0.25;
                      break;
                    }
                    case 2: {
                      const condition =
                        item.attributes.types_names[0] !== 'UNCLASSIFIED' && item.attributes.subtype !== 'VirusTotal';
                      item.attributes.cerberus = condition ? 1 : 0.7;
                      break;
                    }
                  }
                }
              }
              return item;
            });
            this.count = meta.pagination.count <= 10000 ? meta.pagination.count : 10000;
            this.totalResources = meta.pagination.count;
          }
        },
        (error) => {
          if (error.status === 500) {
            this.listError = 'There was a problem with the search request.';
          } else if (error.status === 400) {
            this.listError = this.searchText
              ? 'Incorrect dork syntax. Please, check the Syntax help to guide you with this problem.'
              : 'There was a problem with the search request.';
          }
        }
      );
  }

  private limitDorkToBeSentByHttpGet(str: string) {
    const text = encodeURIComponent(str);
    if (text.length > 2000) {
      let value = text.substr(0, 2008);
      const index = value.lastIndexOf('%20OR%20');
      if (index !== -1) {
        value = value.substr(0, index);
      }
      const newDork = decodeURIComponent(value);
      const elements = newDork.split(' OR ');
      const count = elements.length;
      let lastItem = elements[count - 1];
      lastItem = lastItem.replace(/.*:"(.*)".*/, (match, $1) => $1);
      return { value: newDork, lastItem, count };
    }
    return { value: str, lastItem: '' };
  }

  private processSearchText(text: string): string {
    if (text.includes(',')) {
      const items = [
        ...new Set(
          text
            .split(',')
            .slice(0, 100)
            .filter((item) => !!item)
            .map((item) => item.trim().toLowerCase())
        )
      ];
      const dorkLikeItems = items.map((item) => this.dorkingText(item));
      return dorkLikeItems.join(' OR ');
    } else {
      return text;
    }
  }

  private dorkingText(text) {
    if (isMD5(text)) {
      return `md5:"${text}"`;
    } else if (isSHA1(text)) {
      return `sha1:"${text}"`;
    } else if (isSHA256(text)) {
      return `sha256:"${text}"`;
    } else if (isSHA512(text)) {
      return `sha512:"${text}"`;
    } else {
      return `type:~"${text.toUpperCase()}"`;
    }
  }

  private checkStatusForDetails(status): boolean {
    switch (status) {
      case 'QUEUED':
      case 'DISCARDED':
      case 'BLACKLISTED':
      case 'UNKNOWN':
        return false;
    }
    return true;
  }

  private getStatusIcon(value): string {
    let classStatusValue = 'icon-question-circle-solid text-danger';
    if (this.statusValues.hasOwnProperty(value.toString().toUpperCase())) {
      classStatusValue = this.statusValues[value.toString().toUpperCase()];
    }
    return classStatusValue;
  }

  private getSearchKey(value) {
    if (!value) {
      return 'sha256';
    }
    if (/^(?=[a-f0-9])(?:.{32})$/i.test(value)) {
      return 'md5';
    }
    if (/^(?=[a-f0-9])(?:.{40})$/i.test(value)) {
      return 'sha1';
    }
    if (/^(?=[a-f0-9])(?:.{64})$/i.test(value)) {
      return 'sha256';
    }
    if (/^(?=[a-f0-9])(?:.{128})$/i.test(value)) {
      return 'sha512';
    }
    return 'sha256';
  }
}
