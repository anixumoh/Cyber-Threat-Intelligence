import { Component, OnDestroy, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { Subject } from 'rxjs';
import { take, finalize, takeUntil } from 'rxjs/operators';
import { ToastrService } from 'ngx-toastr';
import * as moment from 'moment';

import { MalwaresStore } from './malwares-store';
import { MalwareSourcesStore } from './malware-sources-store';
import { MalwaresService } from '../../../core/models/malwares.service';
import { MalwareMapStore } from './malware-map-store';
import { OrganizationService } from 'app/dashboard/organization/organization.service';
import { convertToCSV, exportClientFile } from '../../../utils/functions';

import { IndicatorsService } from '../../../core/models/indicators.service';

@Component({
  selector: 'app-malwares-details',
  templateUrl: './malwares-details.component.html',
  styleUrls: ['./malwares-details.component.scss'],
})
export class MalwaresDetailsComponent implements OnInit, OnDestroy {
  malwareId = '';
  loading = false;
  moduleId = '';
  organizationId = '';
  tabs: Array<{ name: string; link: string; icon?: string }> = [
    { name: 'Summary', link: 'summary' },
    { name: 'Signatures', link: 'signatures' },
    { name: 'Behavior', link: 'behavior' },
    { name: 'API Calls', link: 'api_calls' },
    { name: 'Network', link: 'network' },
    { name: 'Files', link: 'files' },
    { name: 'Memory', link: 'memory' },
    { name: 'Configs', link: 'configs' },
    { name: 'IoA', link: 'ioa' },
  ];
  notFound = false;
  serverError = false;
  virustotalUrl = '';
  backendData;
  queryParams: { dork?: string } = {};
  private readonly destroy$ = new Subject<void>();

  constructor(
    private malwaresStore: MalwaresStore,
    private malwareSourcesStore: MalwareSourcesStore,
    private route: ActivatedRoute,
    private malwaresService: MalwaresService,
    private malwareMapStore: MalwareMapStore,
    private toastrService: ToastrService,
    private router: Router,
    private organizationService: OrganizationService,
    private indicatorsService: IndicatorsService
  ) {}

  ngOnInit() {
    this.malwareId = this.route.snapshot.params['malwareId'];
    const { dork } = this.route.snapshot.queryParams;
    if (dork) {
      this.queryParams.dork = dork;
    }
    this.generateUrl();
    this.loading = true;
    this.malwaresStore
      .getData(this.malwareId)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => (this.loading = false))
      )
      .subscribe(
        (response) => {
          this.backendData = response.data;
          this.checkForOptionalTabs(response.data);
          this.getIndicatorsTabs(this.malwareId, 'malware');
        },
        (error) => {
          if (error.status === 404) {
            this.notFound = true;
          } else {
            this.serverError = true;
          }
        }
      );

    this.organizationService
      .getCurrentContext()
      .pipe(takeUntil(this.destroy$))
      .subscribe((context) => {
        this.organizationId = context.currentOrganization.id;
        this.moduleId = context.currentModule.id;
      });
    this.malwareSourcesStore.getData(this.malwareId);
    this.malwareMapStore.getData(this.malwareId);
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.malwaresStore.setState(null);
  }

  getIndicatorsTabs(id, type) {
    this.indicatorsService
      .details({ id, type })
      .pipe(
        takeUntil(this.destroy$),
        take(1),
        finalize(() => (this.loading = false))
      )
      .subscribe(({ data }: any) => {
        if (data && data.relationships) {
          const { relationships } = data;
          if (relationships.threat_actors && relationships.threat_actors.meta.count > 0) {
            this.tabs.push({
              name: 'Threat Actors',
              link: 'actors',
              icon: 'icon-users',
            });
          }
          if (relationships.campaigns && relationships.campaigns.meta.count > 0) {
            this.tabs.push({
              name: 'Campaigns',
              link: 'campaigns',
              icon: 'icon-bullhorn',
            });
          }
        }
      });
  }

  reanalyze() {
    this.malwaresService
      .reanalyzeSample(this.malwareId)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => this.toastrService.success('Sample has been sent to be reanalyzed', 'Success'));
  }

  downloadReport() {
    this.download(this.malwaresService.downloadReport(this.malwareId));
  }

  downloadSample() {
    this.download(this.malwaresService.downloadSample(this.malwareId));
  }

  downloadPcap() {
    this.download(this.malwaresService.downloadPcap(this.malwareId));
  }

  exportToCSV() {
    if (this.backendData) {
      const csvInfo = this.extractCsvData(this.backendData);
      exportClientFile(convertToCSV([csvInfo]), 'malware-details');
    }
  }

  exportToJson() {
    if (this.backendData) {
      exportClientFile(JSON.stringify(this.backendData), 'malware-details', 'json');
    }
  }

  backToList() {
    const { dork } = this.route.snapshot.queryParams;
    this.router.navigate(
      [`dashboard/organizations/${this.organizationId}/modules/${this.moduleId}/threat_context/malwares`],
      { queryParams: { dork } }
    );
  }

  private download(downloadMethod) {
    this.toastrService.info('Download will start quickly', 'info');
    downloadMethod
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => this.toastrService.success('Download started', 'Success'));
  }

  private generateUrl() {
    this.virustotalUrl = 'https://www.virustotal.com/en/file/' + this.malwareId + '/analysis/';
  }

  private checkForOptionalTabs(data) {
    if (data && data.blueliv) {
      if (data.blueliv.ioa) {
        if (data.blueliv.ioa.attack_patterns && data.blueliv.ioa.attack_patterns.length > 0) {
          this.tabs.push({ name: 'ATT&CKÂ®', link: 'attack-patterns' });
        }
        if (data.blueliv.ioa.certificates && data.blueliv.ioa.certificates.length > 0) {
          this.tabs.push({ name: 'Certificates', link: 'certificates' });
        }
      }
    }
  }

  private extractCsvData(data) {
    const { info, target, blueliv, virustotal } = data;
    const malwareType = blueliv.malware_type;
    const signatures = blueliv.malicious;
    let maliciousness = 0;
    if (blueliv && blueliv.cerberus && blueliv.cerberus.hasOwnProperty('probabilities')) {
      maliciousness = blueliv.cerberus.probabilities.malicious * 100;
    } else {
      if (signatures === 'SUSPICIOUS') {
        maliciousness = 25;
      }
      if (signatures === 'MALICIOUS' || malwareType !== 'UNCLASSIFIED') {
        maliciousness = 100;
      }
    }
    const started = info.started ? moment(info.started).format('DD/MM/YYYY HH:mm:ss') : '';
    const peidSignatures =
      blueliv.ioa.metadata && blueliv.ioa.metadata.peid_signatures
        ? (blueliv.ioa.metadata.peid_signatures || []).join(', ')
        : '';
    const signingDate =
      blueliv.ioa.metadata && blueliv.ioa.metadata.signing_date
        ? moment(blueliv.ioa.metadata.signing_date).format('DD/MM/YYYY HH:mm:ss')
        : '';
    const compilationTime =
      blueliv.ioa.metadata && blueliv.ioa.metadata.pe_timestamp
        ? moment(blueliv.ioa.metadata.pe_timestamp).format('DD/MM/YYYY HH:mm:ss')
        : '';
    const detectionRatio = virustotal && virustotal.summary ? virustotal.summary.detection_ratio : '';

    return {
      MD5: target.file.md5,
      SHA1: target.file.sha1,
      SHA256: target.file.sha256,
      MALWARE_TYPE: malwareType,
      MALWARE_SUBTYPE: blueliv.subType.name,
      MALWARE_FOUND: (blueliv.malware_types || []).join(','),
      DETECTION_RATIO: detectionRatio,
      BLUELIV_MALICIOUSNESS: `${maliciousness}%`,
      FILE_TYPE: target.file.type,
      PLATFORM: info.platform,
      SIZE: `${target.file.size} bytes`,
      FILENAME: target.file.name,
      // 'FIRST SEEN': moment(blueliv.first_seen, 'YYYY-MM-DD[T]HH:mm:ss').format('DD/MM/YYYY'),
      // 'LAST SEEN': moment(blueliv.last_seen, 'YYYY-MM-DD[T]HH:mm:ss').format('DD/MM/YYYY'),
      LAST_ANALYSIS: started,
      ANALYSIS_DURATION: `${info.duration}s`,
      COMPILATION_TIME: compilationTime,
      CRC32: target.file.crc32,
      SSDEEP: target.file.ssdeep,
      IMPHASH: blueliv.ioa.metadata.pe_imphash,
      PACKER: blueliv.packer,
      PEID: peidSignatures,
      BINARY_SIGNED: signingDate,
      MATCHED_SIGNATURES: info.matched_signatures || 0,
    };
  }
}
