import { Component, Inject, forwardRef, OnInit, OnDestroy, HostListener } from '@angular/core';
import { Subscription } from 'rxjs';
import * as _ from 'lodash';
import { DetailsMalwareComponent } from '../details-malware.component';
import { isEmpty } from 'app/utils/functions';
import { SummaryTabModel } from 'app/dashboard/module-sections/threats/details-malware/summary-tab/summary-tab.model';
import { InfiniteScrollModel } from 'app/dashboard/module-sections/shared/infinite-scroll/infinite-scroll.model';

@Component({
  selector: 'app-summary-tab',
  templateUrl: './summary-tab.component.html',
  styleUrls: ['./summary-tab.component.scss'],
})
export class SummaryTabComponent implements OnInit, OnDestroy {
  hosts: any;
  resource: any;
  signatures;
  network;
  infiniteScroll_num = 8;
  infiniteScroll_scrollPercent = 20;
  infiniteScroll_page = 0;
  infiniteScrollHttpItems = new InfiniteScrollModel(
    [],
    this.infiniteScroll_scrollPercent,
    this.infiniteScroll_num,
    this.infiniteScroll_page
  );
  subscriptionsList: Subscription[] = [];

  signaturesHeader = [{ value: 'Description' }, { value: 'Severity', class: 'text-center' }];

  domainsHeader = [{ value: 'DNS' }, { value: 'Address', class: 'text-center' }];

  httpHeader = [
    { value: 'Destination' },
    { value: 'Method', class: 'text-center' },
    { value: 'URL', class: 'text-center' },
    { value: 'Data', class: 'text-center' },
  ];

  hostsHeader = [
    { value: 'Address' },
    { value: 'Port', class: 'text-center' },
    { value: 'Protocol', class: 'text-center' },
  ];

  constructor(@Inject(forwardRef(() => DetailsMalwareComponent)) private parentComponent: DetailsMalwareComponent) {}

  ngOnInit() {
    this.resource = new SummaryTabModel();
    let s = this.parentComponent.summaryTabResourceSubject.subscribe((res) => {
      if (res !== 'first') {
        if (res && !isEmpty(res)) {
          this.resource = JSON.parse(JSON.stringify(res));
        }
        this.setSummaryTab();
      }
    });
    this.subscriptionsList.push(s);
  }

  ngOnDestroy() {
    this.unsubscribe();
  }

  unsubscribe() {
    this.subscriptionsList.forEach((subscription) => {
      if (subscription.unsubscribe) {
        subscription.unsubscribe();
      }
    });
  }

  setSummaryTab() {
    this.signatures = this.resource.signatures;
    this.setSignatures();
    this.network = this.resource.network;
    this.setNetwork();
  }

  setSignatures() {
    if (this.signatures) {
      if (this.signatures.length) {
        this.signatures.forEach((it) => {
          it.resourceDataByModule = [
            {
              title: it.name ? it.name : '-',
              isTitle: true,
              value: it.description,
            },
            {
              isSeverity: true,
              value: it.severity != null ? it.severity : 0,
              class: 'td-center',
            },
          ];
        });
      }
    }
  }

  setNetwork() {
    if (this.network) {
      this.network.domains.forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.domain ? it.domain : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.ip ? it.ip : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
        ];
      });

      this.network.http.forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.host ? it.host + (it.port ? ':' + it.port : '') : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.method ? it.method : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.uri ? it.uri : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.data ? it.data : '-',
            class: 'td-center',
            elementClass: 'mb-0 hash',
          },
        ];
      });

      this.infiniteScrollHttpItems = new InfiniteScrollModel(
        this.network.http,
        this.infiniteScroll_scrollPercent,
        this.infiniteScroll_num,
        this.infiniteScroll_page
      );

      let arrayOfIndex = [];
      let index = 0;
      let tcpTemp = this.network.hosts
        .filter((host) => {
          let temp = this.network.tcp.find((tcp, i) => {
            if (host == tcp.dst) {
              arrayOfIndex[index] = i;
              index++;
              return true;
            }
            return false;
          });
          return temp;
        })
        .map((host, j) => {
          return {
            address: host,
            port: this.network.tcp[j].dport,
            protocol: 'tcp',
          };
        });

      arrayOfIndex = [];
      index = 0;
      let udpTemp = this.network.hosts
        .filter((host) => {
          return this.network.udp.find((udp, i) => {
            if (host == udp.dst) {
              arrayOfIndex[index] = i;
              index++;
              return true;
            }
            return false;
          });
        })
        .map((host, j) => {
          return {
            address: host,
            port: this.network.udp[j].dport,
            protocol: 'udp',
          };
        });

      this.hosts = tcpTemp.concat(udpTemp);

      this.hosts.forEach((it) => {
        it.resourceDataByModule = [
          {
            value: it.address ? it.address : '-',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.port ? it.port : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
          {
            value: it.protocol ? it.protocol : '-',
            class: 'td-center',
            elementClass: 'mb-0 text-90 font-weight-normal',
          },
        ];
      });
    }
  }

  @HostListener('scroll', ['$event'])
  onScroll(event, fn, obj) {
    fn.call(obj, event);
  }
}
