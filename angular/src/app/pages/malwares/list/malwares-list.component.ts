import { Component, OnDestroy, OnInit } from '@angular/core';
import { Subject } from 'rxjs';
import { take, finalize, takeUntil } from 'rxjs/operators';
import { ISelectItem } from '../../../shared/components/select/select.component';
import { MalwaresService } from '../../../core/models/malwares.service';
import * as moment from 'moment';
import { OrganizationService } from '../../../dashboard/organization/organization.service';
import { ResourcesService } from '../../../services/resources.service';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-malwares-list',
  templateUrl: './malwares-list.component.html',
  styleUrls: ['./malwares-list.component.scss'],
})
export class MalwaresListComponent implements OnInit, OnDestroy {
  items: any = [];
  loading = false;
  searchText = '';
  bulk = false;
  isDeleteConfirmationOpened = false;
  page = 0;
  count = 0;
  limit = 10;
  limits: ISelectItem[] = [
    { name: '10', value: 10 },
    { name: '15', value: 15 },
    { name: '20', value: 20 },
    { name: '30', value: 30 },
    { name: '50', value: 50 },
  ];
  filename = 'abc';
  uploadHistory = new Map();
  activeModule;
  activeOrganization;
  private readonly destroy$ = new Subject<void>();

  constructor(
    private malwaresService: MalwaresService,
    private organizationService: OrganizationService,
    private resourcesService: ResourcesService,
    private toastrService: ToastrService
  ) {}

  join(data, char) {
    return data.join(char);
  }

  score(value) {
    return value !== null ? Math.round(value * 100) : '-';
  }

  ngOnInit() {
    this.organizationService
      .getCurrentContext()
      .pipe(takeUntil(this.destroy$), take(1))
      .subscribe((context) => {
        this.activeModule = context.currentModule;
        this.activeOrganization = context.currentOrganization;
        this.list();
      });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  setCheckedState(event) {
    this.items = this.items.map((item) => {
      if (item.id) {
        return { ...item, fxSelected: event.target.checked };
      }
      return item;
    });
  }

  setChecked() {
    setTimeout(() => {
      this.bulk = this.getCheckedItems().length === this.getActiveItems().length;
    });
  }

  getActiveItems() {
    return this.items.filter((item) => item.id);
  }

  getCheckedItems() {
    return this.items.filter((item) => item.fxSelected && item.id);
  }

  hasSomeChecked() {
    return this.items.some((item) => item.fxSelected && item.id);
  }

  openDeleteModal() {
    const items = this.getCheckedItems();
    if (items && items.length > 0) {
      this.isDeleteConfirmationOpened = true;
    }
  }

  destroySelected() {
    const items = this.getCheckedItems();
    if (items && items.length > 0) {
      const orgId = this.activeOrganization.id;
      const { id, moduleName } = this.activeModule;
      this.loading = true;
      this.resourcesService
        .deleteResourceStandAlone(
          orgId,
          id,
          `${moduleName}/malware`,
          items.map((item) => item.id)
        )
        .pipe(
          takeUntil(this.destroy$),
          take(1),
          finalize(() => (this.loading = false))
        )
        .subscribe(
          () => this.list(),
          () => this.toastrService.error('Something went wrong while trying to process your request. Please try again.')
        );
    } else {
      this.toastrService.warning('At least one resource must be selected.', 'Error');
    }
  }

  onRemoveHistory(event) {
    this.uploadHistory.delete(event.id);
  }

  onUpload(files) {
    for (let item of files) {
      if (item.id && item.file) {
        this.uploadHistory.set(item.id, { ...item, ...{ inProgress: 9999999, error: undefined } });
        const organizationId = this.activeOrganization.id;
        const moduleId = this.activeModule.id;
        const moduleName = this.activeModule.moduleName;
        this.malwaresService
          .uploadMalwareFile(organizationId, moduleId, moduleName, item.file)
          .pipe(takeUntil(this.destroy$))
          .subscribe(
            (time: any) => {
              if (time) {
                const { estimated } = time;
                if (estimated && estimated > 0) {
                  this.uploadHistory.set(item.id, { ...item, ...{ inProgress: +estimated, error: undefined } });
                } else {
                  this.uploadHistory.set(item.id, { ...item, ...{ inProgress: 9999999, error: undefined } });
                }
              }
            },
            (error) => {
              this.uploadHistory.set(item.id, { ...item, ...{ inProgress: 0, error } });
            },
            () => {
              this.uploadHistory.set(item.id, { ...item, ...{ inProgress: 0 } });
              this.list();
            }
          );
      }
    }
  }

  getHistory() {
    return [...this.uploadHistory.values()];
  }

  reload() {
    this.page = 0;
    this.list();
  }

  onChangeLimit(item: ISelectItem) {
    this.limit = item.value;
    this.reload();
  }

  search() {
    this.reload();
  }

  onPageChange({ page }) {
    this.page = page;
    this.list();
  }

  timeFromNow(date) {
    if (!date) {
      return '-';
    }
    return moment(date).fromNow();
  }

  destroy(item) {
    const id = item.id ? item.id : item.md5;
    if (id) {
      const organizationId = this.activeOrganization.id;
      const moduleId = this.activeModule.id;
      this.loading = true;
      this.malwaresService
        .destroy({ organizationId, moduleId, id })
        .pipe(
          takeUntil(this.destroy$),
          take(1),
          finalize(() => (this.loading = false))
        )
        .subscribe(() => {
          this.list();
        });
    }
  }

  list() {
    const organizationId = this.activeOrganization.id;
    const moduleId = this.activeModule.id;
    this.loading = true;
    const params: any = { maxRows: this.limit, page: this.page };
    if (this.searchText) {
      params.q = this.searchText;
    }
    this.malwaresService
      .list({ organizationId, moduleId, params })
      .pipe(
        takeUntil(this.destroy$),
        take(1),
        finalize(() => (this.loading = false))
      )
      .subscribe((response) => {
        this.items = response.list || [];
        this.count = response.total_resources;
      });
  }
}
