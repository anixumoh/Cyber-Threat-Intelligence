import { take, finalize, takeUntil } from 'rxjs/operators';
import { Component, ElementRef, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { ProcessTreeRenderService } from './processtree.render.service';
import { ProcessTreeEventHandlerService } from './processtree.event_handler.service';
import { MalwaresService } from '../../../../core/models/malwares.service';
import { MalwaresStore } from '../malwares-store';
import { Subject } from 'rxjs';
import { OrganizationService } from '../../../../dashboard/organization/organization.service';

@Component({
  selector: 'app-malware-details-behavior',
  templateUrl: './malware-details-behavior.component.html',
  styleUrls: ['./malware-details-behavior.component.scss'],
})
export class MalwareDetailsBehaviorComponent implements OnInit, OnDestroy {
  data = [];
  @ViewChild('ProcessTreeDiv') element: ElementRef;
  loading = false;
  loadingProcessTree = false;
  cache = {};
  isEmpty = false;
  drawer;
  lifeSubject = new Subject();
  processBehavior;
  activeModule;
  activeOrganization;
  private nodes = [];
  private links = [];
  private malwareId: string;
  private subscription = null;

  constructor(
    private processTreeService: ProcessTreeRenderService,
    private eventService: ProcessTreeEventHandlerService,
    private route: ActivatedRoute,
    private malwaresService: MalwaresService,
    private malwaresStore: MalwaresStore,
    private organizationService: OrganizationService
  ) {}

  ngOnInit() {
    this.organizationService
      .getCurrentContext()
      .pipe(take(1))
      .subscribe(context => {
        this.activeModule = context.currentModule;
        this.activeOrganization = context.currentOrganization;
      });

    this.malwaresStore.state$.pipe(takeUntil(this.lifeSubject)).subscribe(data => {
      if (data) {
        this.malwareId = data.malwareId;
        this.loadingProcessTree = true;
        this.malwaresService
          .getProcessTree(this.malwareId)
          .pipe(
            take(1),
            finalize(() => (this.loadingProcessTree = false))
          )
          .subscribe(response => {
            if (response.data) {
              this.data = response.data;
              if (this.data.length > 0) {
                this.prepareTreeData();
                this.renderTree();
              }
            }
          });
      }
    });

    this.subscription = this.eventService.processTreeEvent.subscribe(value => {
      if (value) {
        if (value.type === 'ip') {
          const url = `/dashboard/organizations/${this.activeOrganization.id}/modules/${this.activeModule.id}/threat_context/indicators/ip/resource/${value.data.value}`;
          window.open(url, '_blank');
          return;
        }

        if (value.type === 'domain') {
          const url = `/dashboard/organizations/${this.activeOrganization.id}/modules/${this.activeModule.id}/threat_context/indicators/fqdn/resource/${value.data.value}`;
          window.open(url, '_blank');
          return;
        }
        this.drawer = true;
        this.processBehavior = undefined;
        if (value['type'] === 'click') {
          const { pid } = value.data;
          this.loading = true;
          this.malwaresService
            .behaviorDetails(this.malwareId, pid)
            .pipe(
              take(1),
              finalize(() => (this.loading = false))
            )
            .subscribe(resp => {
              const response = resp.data;
              if (response) {
                const data = [];
                if (response['behavior']['generic'].length > 0) {
                  for (const key in response['behavior']['generic'][0]) {
                    if (response['behavior']['generic'][0][key]) {
                      data.push({ key, value: response['behavior']['generic'][0][key] });
                    }
                  }
                }
                data.push({ key: 'info', value: response['info'] });
                data.push({ key: 'apistats', value: response['apistats'] });
                this.cache[pid] = data;
                this.setBehavior(data);
              }
            });
        } else if (value['type'] === 'click-reopen_dialog') {
          const { pid } = value.data;
          const data = this.cache[pid];
          if (data) {
            this.setBehavior(data);
          }
        }
      }
    });
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.eventService.processTreeEvent.next(null);
    this.drawer = false;
  }

  private setBehavior(newData: any[]) {
    this.processBehavior = {
      type: 'behavior',
      origin: 'behavior',
    };

    for (const item of newData) {
      const key = item['key'];
      const value = item['value'];
      this.processBehavior[key] = value;
    }
  }

  private getOrderedData() {
    return this.data;
  }

  private addSpecialNode(nodeType) {
    const key = nodeType.toLowerCase();
    const processname = '';
    let icon = '';
    if (nodeType === 'target') {
      icon = 'target_generic';
    }
    if (nodeType === 'persistence') {
      icon = 'scheduler';
    }
    this.addNode({
      process_name: processname,
      malware_type: '',
      pid: key,
      actions: [],
      type: icon,
    });
  }

  private addNodeAction(data) {
    let icon = 'default';
    let tipText = '';
    const nodeType = data['type'];
    let text = '';
    let type = '';
    const newNode = {
      key: data['id'],
      text: '',
      category: nodeType,
      ppid: data['ppid'],
      icon: 'default',
      iconWidth: 30,
      iconHeight: 30,
      portHeight: 15,
      tip_text: '',
    };
    if (nodeType === 'network') {
      icon = 'network';
      tipText = 'Network Connection:\n';
      text = data['raw_data'];
      type = data['raw_type'];
    }
    if (nodeType === 'signature') {
      icon = 'signature';
      text = data['raw_data'];
      tipText = 'Title:\nDescription:\n';
    }
    if (nodeType === 'dropped') {
      icon = 'dropped';
      const split = data['raw_data'].split('\\');
      text = split[split.length - 1];
      tipText = data['tip_text'];
    }
    newNode['icon'] = icon;
    newNode['tip_text'] = tipText;
    newNode['text'] = text;
    if (type) {
      newNode['type'] = type;
    }
    this.nodes.push(newNode);
  }

  private addNode(process) {
    // insert only if the node does not exist
    const index = this.nodes.findIndex(x => x.key === process['key']);
    if (index === -1) {
      let title = process['pid'];
      if (process.hasOwnProperty('title')) {
        title = process['title'];
      }
      const newNode = {
        key: process['pid'],
        process_name: process['process_name'],
        malware_type: process['malware_type'],
        pid: process['pid'],
        title,
        icon: process['type'],
        iconWidth: 30,
        iconHeight: 30,
        portHeight: 15,
        tip_text: process['pid'] + ' - ' + process['process_name'] + '\n\nType: ' + process['malware_type'],
      };
      if (process['malware_type'] !== '' && process['malware_type'] !== 'UNCLASSIFIED') {
        newNode['color'] = '#ff0b30';
        newNode['icon'] = 'malicious_shield';
        newNode['process_name'] = process['process_name'] + '\n' + process['malware_type'];
      }
      this.nodes.push(newNode);
      this.setActions(process);
    }
  }

  private addLink(from, to, label, linkType = '') {
    const newLink = {
      from,
      to,
      label,
    };
    if (linkType === 'injection') {
      newLink['category'] = 'Injection';
      newLink['text'] = 'Process Injection';
      newLink['tip_text'] = 'Process Injection using:\n' + label;
    }
    this.links.push(newLink);
  }

  private checkPersistence(process) {
    if (process.hasOwnProperty('persistence') && process['persistence']) {
      this.addSpecialNode('persistence');
      this.addLink('persistence', process['pid'], 'on restart');
    }
  }

  private isChildrenProcess(pid, children) {
    for (const child of children) {
      if (pid === child['pid']) {
        return true;
      }
    }
    return false;
  }

  private checkInjection(process) {
    const children = process['children'];
    if (process.hasOwnProperty('ipid')) {
      const ipids = process['ipid'];
      for (const ipid of ipids) {
        for (const key in ipid) {
          if (ipid[key]) {
            const injected_pid = key;
            const process_pid = process['pid'];
            const label = ipid[key].toString().replace('\n', '');
            // we only add the link within nodes even if we haven't checked that
            // the ipid exists. This might cause inconsistences, but at this
            // point we don't have ipid data to add the node.
            if (!this.isChildrenProcess(injected_pid, children)) {
              this.addLink(process_pid, injected_pid, label, 'injection');
            }
          }
        }
      }
    }
  }

  private checkChildrenLabelForInjection(child) {
    const output = [];
    if (child.hasOwnProperty('ppid')) {
      if (child.hasOwnProperty('ippid')) {
        const ppid = child['ppid'];
        const ippids = child['ippid'];
        for (const ippid of ippids) {
          if (ippid.hasOwnProperty(ppid)) {
            output.push(ippid[ppid].toString().replace('\n', ''));
          }
        }
      }
    }
    return output;
  }

  private checkChildren(process) {
    const children = process['children'];
    for (const child of children) {
      if (process['pid'] === child['ppid']) {
        const label = this.checkChildrenLabelForInjection(child);
        if (label.length > 0) {
          this.addLink(process['pid'], child['pid'], 'spawns\n(' + label + ')');
        } else {
          this.addLink(process['pid'], child['pid'], 'spawns');
        }
      }
    }
    return children;
  }

  private setSignaturesActions(process) {
    if (process['signatures'].length <= 0) {
      return;
    }
    let index = 0;
    this.addNode({
      process_name: '',
      malware_type: '',
      pid: 'signature_' + process['pid'],
      actions: [],
      type: 'default',
      title: '',
    });
    this.addLink(process['pid'], 'signature_' + process['pid'], 'signatures (' + process['signatures'].length + ')');
    for (const sig of process['signatures']) {
      const process_pid = process['pid'];
      const sig_id = process_pid + '_sig_' + index.toString();
      const data = {
        id: sig_id,
        ppid: process_pid,
        raw_data: sig,
        type: 'signature',
      };
      this.addNodeAction(data);
      this.addLink('signature_' + process['pid'], sig_id, '');
      index = index + 1;
    }
  }

  private setNetworkActions(process) {
    let index = 0;
    for (const net of process['network']) {
      const process_pid = process['pid'];
      const net_id = process_pid + '_net_' + index.toString();
      const data = {
        id: net_id,
        ppid: process_pid,
        raw_data: net['value'],
        raw_type: net['type'],
        type: 'network',
      };
      this.addNodeAction(data);
      this.addLink(process_pid, net_id, '');
      index = index + 1;
    }
  }

  private setDroppedActions(process) {
    if (process['dropped'].length <= 0) {
      return;
    }
    let index = 0;
    this.addNode({
      process_name: '',
      malware_type: '',
      pid: 'dropped_' + process['pid'],
      actions: [],
      type: 'dropped',
      title: '',
    });
    this.addLink(process['pid'], 'dropped_' + process['pid'], 'dropped (' + process['dropped'].length + ')');
    for (const drop of process['dropped']) {
      if (drop['type'] === 'file') {
        const process_pid = process['pid'];
        const drop_id = process_pid + '_dropped_' + index.toString();
        const data = {
          id: drop_id,
          ppid: process_pid,
          raw_data: drop['value'],
          type: 'dropped',
          tip_text: drop['value'],
        };
        this.addNodeAction(data);
        this.addLink('dropped_' + process['pid'], drop_id, 'drops');
        index = index + 1;
      }
    }
  }

  private setActions(process) {
    if (process.hasOwnProperty('signatures')) {
      this.setSignaturesActions(process);
    }
    if (process.hasOwnProperty('network')) {
      this.setNetworkActions(process);
    }
    if (process.hasOwnProperty('dropped')) {
      this.setDroppedActions(process);
    }
  }

  private prepareTreeData() {
    // this function is a kind of recursive function, so then
    // to implement it we will have a queue list when we will
    // pull and push elements. The queue will be iterated until
    // is empty.

    const processQueueList = this.getOrderedData().slice(0);
    this.addSpecialNode('target');

    const initLengthQueue = processQueueList.length;
    let index = 0;
    while (processQueueList.length > 0) {
      const process = processQueueList.shift();
      process['type'] = 'process';
      this.addNode(process);

      if (index < initLengthQueue) {
        // we are on the root list of processess
        // we have to add a link within the target
        // and the spawned process
        if (!process.hasOwnProperty('persistence') || process['persistence'] !== true) {
          this.addLink('target', process['pid'], 'spawns');
        }
      }
      let childs = [];
      childs = this.checkChildren(process);
      for (const c of childs) {
        processQueueList.push(c);
      }
      this.checkPersistence(process);
      this.checkInjection(process);
      index = index + 1;
    }
  }

  private renderTree() {
    this.processTreeService.render(this.nodes, this.links, this.element);
    this.isEmpty = !(this.nodes && this.nodes.length > 0);
  }
}
