import { Component, Input, Output, EventEmitter, ElementRef, ViewEncapsulation } from '@angular/core';
import * as d3 from 'd3';
@Component({
  selector: 'app-process-tree',
  templateUrl: './process-tree.component.html',
  styleUrls: ['./process-tree.component.scss'],
  encapsulation: ViewEncapsulation.None,
})
export class ProcessTreeComponent {
  _listProcess: any[] = new Array();
  @Input()
  get listProcess() {
    return this._listProcess;
  }
  set listProcess(v) {
    this._listProcess = v;
    this.redraw();
  }

  @Output()
  onCall = new EventEmitter<any>();

  constructor(private el: ElementRef) {}

  redraw() {
    while (this.el.nativeElement.firstChild) {
      this.el.nativeElement.removeChild(this.el.nativeElement.firstChild);
    }
    var listProcess = this.listProcess.slice(0);
    var data = [];
    var hash = {};
    while (listProcess.length > 0) {
      var p = listProcess.shift();
      var pid = p.pid;
      var name = p.process_name;
      if (name.length > 20) {
        name = name.substr(0, 7) + '...' + name.substr(-7);
      }
      var newNode = {
        id: pid,
        name: name,
        type: p.malware_type,
        parent_id: p.ppid,
        process: p,
        class: 'node',
      };
      hash[pid] = data.length;
      data.push(newNode);
      p.children.forEach(function (child) {
        child.ppid = pid;
        listProcess.push(child);
      });
    }
    this.listProcess.forEach(function (e) {
      var pid = e.pid;
      data[hash[pid]].parent_id = 'start';
    });

    data
      .sort(function (a, b) {
        return a.process.first_seen < b.process.first_seen ? -1 : 1;
      })
      .forEach(function (e, k) {
        e.step = k + 1;
      });

    data.push({
      id: 'start',
      class: 'root',
    });

    var svg = d3
      .select(this.el.nativeElement)
      .append('svg')
      .attr('preserveAspectRatio', 'xMinYMin')
      .attr('viewBox', '0 0 600 600')
      .attr('class', 'process-tree');

    var g = svg.append('g').attr('transform', 'translate(-50,0)');

    var tree = d3.cluster().size([600, 600]);

    var stratify = d3.stratify().parentId((d: any) => d.parent_id);

    var root = stratify(data).sort(function (a, b) {
      return a.height - b.height || a.id.localeCompare(b.id);
    });

    tree(root);

    // Per-type markers, as they don't inherit styles.
    svg
      .append('defs')
      .selectAll('marker')
      .data(['end'])
      .enter()
      .append('marker')
      .attr('id', function (d) {
        return d;
      })
      .attr('viewBox', '-3 -5 10 10')
      .attr('refX', 0)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M-3,-5L7,0L-3,5L0,0');

    var link = g
      .selectAll('.link')
      .data(root.descendants().slice(1))
      .enter()
      .append('g')
      .attr('class', (d: any) => (d.parent.data.class == 'root' ? 'root' : 'link'));

    link
      .append('path')
      .attr('marker-end', 'url(#end)')
      .attr('d', (d: any) => {
        return (
          'M' +
          (d.parent.y + 25) +
          ',' +
          d.parent.x +
          'C' +
          (d.parent.y + 120) +
          ',' +
          d.parent.x +
          ' ' +
          (d.y - 160) +
          ',' +
          d.x +
          ' ' +
          (d.y - 50 - 3) +
          ',' +
          d.x
        );
      });

    var node = g
      .selectAll('.node')
      .data(root.descendants())
      .enter()
      .append('g')
      .attr('class', (d: any) => d.data.class)
      .attr('transform', (d: any) => 'translate(' + d.y + ',' + d.x + ')');

    var step = node.append('g').attr('class', 'step').attr('transform', 'translate(-35,0)');

    step.append('circle').attr('r', 10);
    step
      .append('text')
      .attr('y', '0.3em')
      .text(function (d: any) {
        return d.data.step;
      });

    node
      .append('circle')
      .on('click', this.clickNode.bind(this))
      .attr('r', function (d: any) {
        return d.data.class == 'root' ? 10 : 25;
      });

    node
      .append('text')
      .attr('class', 'pid')
      .attr('y', '0.4em')
      .on('click', this.clickNode.bind(this))
      .text(function (d) {
        return '<' + d.id + '>';
      });

    node
      .append('text')
      //.attr("x", function(d) { return d.children ? -8 : 8; })
      .attr('y', -30)
      .attr('class', 'name')
      .on('click', this.clickNode.bind(this))
      .text(function (d: any) {
        return d.data.name;
      });

    node
      .append('text')
      .attr('y', 35)
      //.attr("x", function(d) { return d.children ? -8 : 8; })
      .attr('class', 'type')
      .on('click', this.clickNode.bind(this))
      .text(function (d: any) {
        return d.data.type;
      });
  }

  clickNode(e) {
    var data = e.data.process;
    if (data) {
      this.onCall.emit(data);
    }
  }
  /*
  var listProcess = scope.processes.slice(0);
    }
  */
}
